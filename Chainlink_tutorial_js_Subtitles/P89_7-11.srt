11097
11:08:37,910 --> 11:08:40,190
Alright, so now that we've cleaned this up, 
好了，现在我们已经把这里都整理好了

11098
11:08:40,190 --> 11:08:43,730
we've got to deploy marks, deploy Funmi. 
我们已经有了 "deploy-mocks" 和 "deploy-fund-me" 

11099
11:08:43,730 --> 11:08:46,640
Let's go ahead and start writing some tests. 
让我们开始编写测试吧

11100
11:08:46,640 --> 11:08:50,000
And after we write these tests, we're actually going to run that gas estimator 
等我们写完这些测试，就要运行 "gas estimator" 了

11101
11:08:50,210 --> 11:08:52,370
and using that gas estimator, we're gonna go back, and we're going to update this contract one more time 
使用了 "gas estimator" 我们就可以返回去再次更新合约

11102
11:08:52,370 --> 11:08:56,300
to make this even cheaper to use and work with. 
以使其使用起来更加便宜

11103
11:08:56,540 --> 11:08:58,850
And remember, that's going to be one of the advantages of writing these tests 
记住，编写这些测试的优势之一

11104
11:08:58,850 --> 11:09:01,700
is how we can optimize our contracts to be even faster, more gas efficient, etc, 
就是可以通过它们来优化我们的合约，使其更快速，更节省 gas 等等

11105
11:09:01,700 --> 11:09:05,780
we want to make sure that we write really good tests, 
我们希望确保我们编写的测试非常好

11106
11:09:05,780 --> 11:09:08,540
and this is going to be one of our first jumps into these more professional test setups. 
这将是我们迈向更专业的测试设置的第一步

11107
11:09:08,540 --> 11:09:13,070
So we're going to jump into our test folder, 
所以，现在要跳转到我们的 "test" 文件夹

11108
11:09:13,100 --> 11:09:14,930
we're going to delete this sample test.js. 
我们要删除这个 "sample-test.js"

11109
11:09:14,930 --> 11:09:19,490
In our last section, we went over a really minimalistic test, which is great. 
在上一节中，我们介绍了一个非常简化的测试，已经很不错了

11110
11:09:19,490 --> 11:09:22,880
However, when we get bigger and bigger projects, 
然而，当我们的项目越来越大时

11111
11:09:22,880 --> 11:09:24,950
we're going to want to start testing more and more different things, 
我们就会开始想测试越来越多不同的内容

11112
11:09:24,950 --> 11:09:28,190
we're going to get more and more into at least two different types of testing. 
我们将至少进行两种不同类型的测试

11113
11:09:28,190 --> 11:09:31,100
So if we cd into our test folder, 
如果我们进入 ("cd") 到我们的 "test" 文件夹

11114
11:09:31,100 --> 11:09:33,800
we're going to make one directory called staging. 
我们要创建一个名为 "staging" 的目录

11115
11:09:33,800 --> 11:09:37,310
And then we're going to make another directory called unit. 
接着我们再创建另一个目录名为 "unit"

11116
11:09:37,310 --> 11:09:41,090
And now if we look in our test folder,
现在如果查看我们的 "test" 文件夹

11117
11:09:41,150 --> 11:09:44,450
we now have a staging folder, and a unit test folder. 
就会有一个 "staging" 文件夹和一个 "unit" 文件夹

11118
11:09:44,480 --> 11:09:47,330
Now we're going to talk about two different types of tests. 
现在我们要讨论两种不同的测试类型

11119
11:09:47,330 --> 11:09:49,820
The first one is going to be something called a unit test.
第一种被称为单元 ("Unit") 测试

11120
11:09:49,850 --> 11:09:53,090
Now what is a unit test? 
那么什么是 Unit 测试?

11121
11:09:53,090 --> 11:09:56,690
Unit testing is a software testing method by which individual units of source code are tested.
Unit 测试是一种软件测试方法，用于测试源代码的各个单元

11122
11:09:56,780 --> 11:10:00,320
Basically, what we want to do is in our contracts, 
基本上就是，我们要在我们的合约中

11123
11:10:00,320 --> 11:10:03,680
we want to test minimal portions of our code to make sure that they work correctly. 
测试代码的最小部分，以确保它们正常工作。

11124
11:10:03,710 --> 11:10:07,430
Then once our small pieces of the test work, 
一旦小的测试片段工作正常

11125
11:10:07,430 --> 11:10:11,360
we want to do a staging test or maybe an integration test. 
我们就要进行暂存 ("Staging") 测试或者说集成 ("integration") 测试

11126
11:10:11,360 --> 11:10:15,020
This might be where we run our code on a test net or some actual network. 
这可能就是我们在测试网络或真实网络上运行代码的地方

11127
11:10:15,020 --> 11:10:17,630
You can think of a staging test, it's kind of the last stop before you deploy to a main net. 
你可以将 Staging 测试看作是部署到主网络前的最后一道检查点

11128
11:10:17,660 --> 11:10:21,380
They're not always 100% necessary, 
它们并不总是百分百必要的

11129
11:10:21,380 --> 11:10:24,080
but they can be really, really helpful.
但它们真的非常非常有用

11130
11:10:24,110 --> 11:10:28,130
Remember, we do want to be conscientious of how much we use our test nets, 
记住，我们必须要注意我们使用测试网络的频次

11131
11:10:28,160 --> 11:10:32,060
but we absolutely would 100% want to make sure that everything works locally 
我们必须要确保所有东西都能在本地正常工作

11132
11:10:32,060 --> 11:10:35,480
and that we unit test and we run all of our code locally. 
而且我们要在本地进行 Unit 测试并运行所有代码

11133
11:10:35,510 --> 11:10:39,500
Then we can use staging tests on an actual test net 
接着我们才可以在实际的测试网上使用 Staging 测试

11134
11:10:39,500 --> 11:10:43,400
to make sure that our code will work with actual other contracts. 
以确保我们的代码能与其它合约共同工作

11135
11:10:43,400 --> 11:10:48,740
Now unit tests can be done with local Hard Hat Network or a forked Hard Hat Network, 
Unit 测试可以使用 "local hardhat" 或者 "forked hardhat"

11136
11:10:48,770 --> 11:10:52,070
we'll talk about this for tar Hat Network very soon, 
我们很快就会讨论这个 "forked hardhat"

11137
11:10:52,070 --> 11:10:55,820
right, now, let's build these unit tests, 
但现在，让我们先来构建 Unit 测试

11138
11:10:55,850 --> 11:10:58,340
these unit tests are going to be basically what we saw in our last section. 
这些 Unit 测试基本上就是我们在上一节中看到的内容

11139
11:10:58,340 --> 11:11:02,090
So let's go in and let's jump in and write some of these unit tests.  
让我们开始编写这些 Unit 测试吧

11140
11:11:02,090 --> 11:11:04,670
So let's create a new test, 
我们来创建一个新的测试

11141
11:11:04,670 --> 11:11:10,370
we'll call it on me dot test dot j, s. 
命名为 "FundMe.test.js"

11142
11:11:10,370 --> 11:11:13,160
And we'll start making our tests in here. 
我们就从这里开始开展我们的测试

11143
11:11:13,160 --> 11:11:15,920
Now, we did test previously in our last section, 
我们在上一节中也做了测试，

11144
11:11:15,920 --> 11:11:18,470
but our tests here are going to look a little bit differently, 
但现在的这个会有一些不同

11145
11:11:18,470 --> 11:11:22,130
we're actually going to use hardhat deploy, to automatically set up our tests 
我们要用 "hardhat deploy" 来自动设置我们的测试

11146
11:11:22,130 --> 11:11:24,860
as if both of these deployed functions had been run. 
就像这两个已经运行过的 "deploy" 函数一样

11147
11:11:24,860 --> 11:11:27,440
So let's go ahead and get this started. 
让我们现在开始吧

11148
11:11:27,440 --> 11:11:32,600
So we're still going to do that same setup that we're gonna do describe, we're gonna say fund me. 
我们仍然是做相同的设置 `describe("FundMe")`

11149
11:11:32,600 --> 11:11:41,540
And this is going to have that async function like so. 
这里面是一个 `async function` 就像这样

11150
11:11:41,570 --> 11:11:46,670
And in here, we're going to have a before each, 
在它的内部，有一个 `beforeEach`

11151
11:11:46,670 --> 11:11:49,730
and we're going to have some hits and some describes and everything. 
我们还会有一些 `it` 和一些 `describe` 以及一些其它东西

11152
11:11:49,730 --> 11:11:52,280
Now since we want to unit test this, 
由于我们要进行的是 Unit 测试

11153
11:11:52,280 --> 11:11:54,470
we're gonna go a little bit heavier on the test here, and then with our last project, 
所以相比上一个项目，我们在这里会进行更加重度的测试

11154
11:11:54,470 --> 11:11:57,140
but in the future, we'll go a little bit lighter with some of the tests. 
但未来，我们会对一些测试做轻量化处理

11155
11:11:57,140 --> 11:12:02,750
So let's get started. 
让我们开始吧

11156
11:12:02,750 --> 11:12:06,770
If we run yarn Hardhead test right now, we're gonna get zero passing. 
如果我们现在运行 `yarn hardhat test` 得到的会是零通过

11157
11:12:08,690 --> 11:12:11,180
Now, if we run yarn hardhat coverage, 
而如果我们运行的是 `yarn hardhat coverage`

11158
11:12:11,510 --> 11:12:15,440
we're gonna get something that looks like this, saying, Hey, you're missing a lot of stuff. 
就会得到一些这样的东西，呃，你漏掉了很多东西

11159
11:12:15,440 --> 11:12:18,680
So let's try to cover some more lines with our tests. 
所以，让我们尝试将测试覆盖更多的行

11160
11:12:18,680 --> 11:12:22,760
And one way we can do that is actually we can group our tests based off of different functions. 
其中一种方式是，我们可以基于功能的不同来对测试进行分组

11161
11:12:22,760 --> 11:12:26,150
So let's have our first set of tests be around our constructor. 
我们的第一组测试将围绕着我们的构造函数展开

11162
11:12:26,150 --> 11:12:29,300
To do that inside of our first describe, we can add another describe, 
因此，在我们的第一个 `describe` 内部，我们可以添加另一个 `describe`

11163
11:12:29,300 --> 11:12:34,250
have this describe the just the constructor, 
这个 `describe` 只涉及构造函数 ("constructor")

11164
11:12:34,280 --> 11:12:37,610
this larger scope will be for the entire Funmi contract. 
这个较大的范围适用于整个 "FundMe" 合约

11165
11:12:37,610 --> 11:12:41,690
And everything inside this one will just be for the constructor. 
而这一个(`describe`)里面的内容只涉及构造函数

11166
11:12:41,690 --> 11:12:45,530
So this will also be an async function. 
这里也是一个 `async function`

11167
11:12:45,530 --> 11:12:48,560
And these tasks will be just for the constructor. 
这些任务将只适用于构造函数

11168
11:12:48,560 --> 11:12:51,380
But before we even work on this describe, we probably want to deploy our Funmi contract. 
但在处理这个 `describe` 之前，得先部署我们的 "FundMe" 合约

11169
11:12:51,380 --> 11:12:54,440
So let's learn how to do that. 
所以让我们来学习一下如何操作

11170
11:12:54,440 --> 11:13:00,950
So we'll do a before each, which will be an async function. 
输入 `beforeEach(async function)`

11171
11:13:00,950 --> 11:13:06,350
And we're going to deploy our Funmi contract using hard hat deploy. 
我们要做的就是部署我们的 "FundMe" 合约，使用 "Hardhat-deploy"

11172
11:13:06,380 --> 11:13:09,350
Since we use hard hat deploy, 
由于我们使用了 "Hardhat-deploy"

11173
11:13:09,350 --> 11:13:11,540
our Funmi contract will come even with our mocks and everything. 
所以我们的 "FundMe" 合约会包括我们的 "mocks" 和其它一切内容

11174
11:13:11,570 --> 11:13:18,500
So above the before each, let's do let me HDMI. 
所以在这个 `beforeEach` 上面，我们要写下 "let fundMe"

11175
11:13:18,500 --> 11:13:21,380
And then here, we're going to deploy Funmi, 
接着在这里，我们就来部署 "FundMe" 

11176
11:13:21,380 --> 11:13:24,140
where we're going to deploy our Funmi contract is first by pulling in our deployments object from Harnett deploy. 
我们首先通过 "Hardhat-deploy" 获取 "deployments" 对象来部署我们的 "FundMe" 合约

11177
11:13:24,140 --> 11:13:28,880
So we'll do const deployments equals require hardhat. 
所以就是 `const {deployments} = require("hardhat")`

11178
11:13:29,930 --> 11:13:33,950
And this deployments object has, has a function called fixture 
而这个 "deployments" 对象有一个名为 `fixture` 的函数

11179
11:13:33,950 --> 11:13:38,300
with fixture does is it allows us to basically run our entire deploy folder 
`fixture` 的作用是允许我们运行整个 "deploy" 文件夹

11180
11:13:38,300 --> 11:13:41,960
with as many tags as we want. 
并且可以使用任意数量的标签("tags")

11181
11:13:41,960 --> 11:13:46,190
You'll notice I added this alt tag in both of our scripts. 
你可以看到，我在全部两个脚本中都添加了这个 "all" 标签

11182
11:13:46,190 --> 11:13:49,940
This means that in this deployment stuff fixtures, 
这意味着，在这个 `deployments.fixture()` 中

11183
11:13:49,970 --> 11:13:53,630
it's gonna be a wait deployment of fixtures. 
抱歉，应该是 `await deployments.fixture()`

11184
11:13:53,720 --> 11:13:56,840
If I run away deployments dot fixture, 
如果我运行 `await deployments.fixture()`

11185
11:13:56,840 --> 11:14:00,200
I'll run through our deploy scripts on our local network and deploy all of the contracts 
就会在我们的本地网络中运行部署脚本并部署全部合约

11186
11:14:00,230 --> 11:14:03,170
that we can use them in our scripts and in our testing, 
这样我们就可以在我们的脚本和测试中使用它们了

11187
11:14:03,170 --> 11:14:07,040
and we can deploy everything in that deploy folder with just this one line. 
我们可以直接部署 "deploy" 文件夹中的所有内容，只需要这么一行代码

11188
11:14:07,040 --> 11:14:09,590
isn't that helpful. 
是不是很好用

11189
11:14:09,590 --> 11:14:15,890
Now, once all of our contracts have been deployed, we can start getting them 
现在，只要我们的所有合约都部署完毕，就可以开始获取它们了 

11190
11:14:15,890 --> 11:14:20,450
will say fund me equals await ethers, and we'll pull an ether some hard hat as well. 
`fundMe = await ethers`，我们得把 "ethers" 也从 "hardhat" 中获取出来

11191
11:14:20,450 --> 11:14:25,010
dot and this is where hard hat deploy is helpful. Again, 
`.` 这就是 "Hardhat-deploy" 再次发挥作用的地方了

11192
11:14:25,010 --> 11:14:29,180
hard to deploy rapt ether is with a function called Get contract, 
"Hardhat-deploy" 为 "ethers" 包装了一个名为 `getContract` 的函数

11193
11:14:29,180 --> 11:14:32,510
this get contract function is going to get the most recent deployment of whatever contract we tell it. 
这个 `getContract` 函数将获取我们告诉它的任意合约的最新部署

11194
11:14:32,510 --> 11:14:36,380
So we'll say get contract of fun to me. 
所以我们写下 `getContract("FundMe")`

11195
11:14:36,380 --> 11:14:40,820
So this will give us the most recent Lee deployed Funmi contract in just this one line. 
这就会为我们提供最新部署的 "FundMe" 合约，只需要这么一行

11196
11:14:40,850 --> 11:14:45,200
And now Funmi will be equal to this line here.
现在 `fundMe` 就是等于，这么一行

11197
11:14:45,410 --> 11:14:48,350
Now we're going to make a bunch of transactions on our Funmi. 
现在我们要在 "FundMe" 上进行一系列交易

11198
11:14:48,350 --> 11:14:52,280
To test it. Of course, we can also tell ethers which account we want connected to fund me. 
为了进行测试，我们可以告诉 "ethers" 我们想把哪个账户连接到 "FundMe"

11199
11:14:52,280 --> 11:14:57,080
So I can say const deployer equals goes away get named accounts, 
所以可以这么写 `const deployer = await getNameAccounts`

11200
11:14:57,620 --> 11:15:03,050
exactly like we did in our deploy scripts. 
就和我们在部署脚本中做的完全一样

11201
11:15:03,050 --> 11:15:06,770
And then we just need to import it from our tap
接着我们只需要把它从 "hardhat" 中导入进来就行了

11202
11:15:06,920 --> 11:15:10,130
in our deploy scripts 
在我们的部署脚本中 

11203
11:15:10,220 --> 11:15:13,970
we imported get named accounts inside of our input parameters for our deploy function.
我们导入了 "getNameAccounts" 作为 "deploy" 函数的输入参数

11204
11:15:14,390 --> 11:15:17,240
Remember getting named accounts and deployments was abstracted from 
记住，"getNameAccounts" 和 "deployments" 是从

11205
11:15:17,240 --> 11:15:20,390
if we look up here,  from the hard hat runtime environment, 
看一下这里，是从 "hardhat" 运行环境中提取出来的

11206
11:15:20,390 --> 11:15:23,030
and like I said, the hard hat runtime environment is basically the same thing as hard hat. 
就像我说的那样，"hardhat" 运行环境基本上就和 "hardhat" 是一回事

11207
11:15:23,030 --> 11:15:25,580
So we can just go ahead and import it like this, 
所以我们可以直接这样导入它

11208
11:15:25,580 --> 11:15:29,180
actually like this. 
应该这样写...

11209
11:15:29,180 --> 11:15:32,210
Because we actually need to abstract just the deployer from getting named accounts. 
因为我们只需要从 "getNameAccounts" 中提取出 "deployer" 就够了

11210
11:15:32,210 --> 11:15:36,290
And now what we can do is we can connect our Deployer to our Fund Me account. 
现在我们就可以把 "deployer" 连接到我们的 "FundMe" 上了

11211
11:15:36,350 --> 11:15:39,830
So whenever we call a function with fund me, 
每当我们用 "fundMe" 调用函数时

11212
11:15:39,830 --> 11:15:43,340
it'll automatically be from that the player account, which is great. 
它都将自动连接到 "deployer" 账户，这非常好

11213
11:15:43,670 --> 11:15:46,070
Another way you can get different accounts 
另一种获取不同账户的方式是

11214
11:15:46,100 --> 11:15:49,250
directly from your heart had config. 
是直接从 "hardhat.config" 中获取

11215
11:15:49,280 --> 11:15:55,400
Is you could take const accounts equals await ethers dot get signers, 
你可以这样做 `const accounts = await ethers.getSigners`

11216
11:15:55,400 --> 11:15:58,640
ethers dot get signers is going to return whatever is in this account section of your network. 
`ethers.getSigners` 会返回你 `networks` 中的 `accounts` 部分

11217
11:15:58,640 --> 11:16:01,790
If you're on your default network hard hat, 
如果你处于 `defaultNetwork` "hardhat" 上的话

11218
11:16:01,790 --> 11:16:04,280
it's going to give you a list of 10 fake accounts that we can work with 
它就会返回一个包含 10 个虚拟账户的列表以供你使用

11219
11:16:04,280 --> 11:16:06,470
you then of course, can do something like const. 
所以当然，你就可以进行一些这样的操作

11220
11:16:06,470 --> 11:16:12,860
Account one equals accounts. 
`accountOne = accounts`

11221
11:16:12,860 --> 11:16:16,100
More correctly would be account zero equals account zero and work like that. 
更正确的写法可能应该是 `accountZero = accounts[0]` 就像这样

11222
11:16:16,100 --> 11:16:17,960
We'll leave that comment that out, just in case you need a reference to it in the future. 
我们会把这一段注释掉，以防将来需要参考

11223
11:16:17,960 --> 11:16:20,390
Okay, great. So now we have our Funmi contract. 
OK 很好，现在我们拥有了 `fundMe` 合约

11224
11:16:20,390 --> 11:16:23,960
Let's go ahead and write some tests for testing the constructor. 
让我们继续编写测试构造函数的测试

11225
11:16:23,960 --> 11:16:25,940
And we're probably going to want to use this deployer object down here. 
我们可能需要在下面用到这个 `deployer` 对象

11226
11:16:25,940 --> 11:16:30,320
So we'll do let deployer above.
所以我们在上面定义一个 `let deployer`

11227
11:16:30,410 --> 11:16:33,920
And we'll do something a little finicky here. 
现在我们要处理一些棘手的事情

11228
11:16:33,920 --> 11:16:39,710
But we'll say deployer equals Wait, get named accounts, dot Deployer. 
我们要改成 `deployer = (await getNameAccounts()).deployer`

11229
11:16:39,710 --> 11:16:42,170
And we'll just wrap this up 
我们要把它用括号包起来

11230
11:16:42,170 --> 11:16:45,410
so that we can just grab this deployer object and assign it to declare like so. 
以便我们可以直接获取这个 `deployer` 对象并将其分配给这个 `deployer`

11231
11:16:45,410 --> 11:16:50,420
Now in here, we'll create our first test, 
现在我们就要创建我们的第一个测试了

11232
11:16:50,450 --> 11:16:56,480
we'll say it will say it sets the Agra Gator addresses correctly. Comma will have this be an async function. 
写下 `it("sets the aggregator addresses correctly", async function (){})`

11233
11:16:56,480 --> 11:17:03,050
And we'll say const response equals await fund me dot, 
然后是 `const response = await fundMe.`

11234
11:17:03,200 --> 11:17:07,850
let's get this price feed here, fund me dot price feed. 
我们来获取一下这里的这个 `priceFeed`，`fundMe.priceFeed()` 

11235
11:17:08,240 --> 11:17:10,880
And then we'll want to make sure this price feed is going to be the same as our Mk V three aggregator 
接着我们要确保这个 `priceFeed` 就是我们的 "MockV3Aggregator"

11236
11:17:10,880 --> 11:17:14,330
since we're going to be running these tests locally. 
因为我们要在本地运行这些测试

11237
11:17:14,330 --> 11:17:18,200
So we should get our mark three V three aggregator up top. 
所以我们应该在顶部获取 "mockV3Aggregator" 

11238
11:17:18,230 --> 11:17:23,960
Let's do let mock v3 aggregate store.
写下 `let mockV3Aggregator`

11239
11:17:25,040 --> 11:17:27,950
And we'll grab this address the same way 
并以相同的方式获取地址

11240
11:17:27,950 --> 11:17:34,010
mockbee Three aggregator equals await ethers dot get contract mockbee Three aggregator comma, 
`mockV3Aggregator = await ethers.getContract("MockV3Aggregator", )`

11241
11:17:34,010 --> 11:17:37,460
we'll connect this one to the deployer as well. 
并同样连接上 `deployer` 

11242
11:17:37,460 --> 11:17:43,880
So we'll want to say cert dot equals cert dot equal response comma lock v3 aggregator dot address. 
所以我们要写的就是 `assert.equal(response, mockV3Aggregator.address)`

11243
11:17:44,660 --> 11:17:50,000
And of course we'll want to say const. Assert equals require gy. 
当然了，还有 `const { assert } = require("chai")`

11244
11:17:50,000 --> 11:17:58,040
Import that from DJI. 
从 "chai" 中把它导入进来

11245
11:17:58,040 --> 11:18:00,170
Okay, cool.
OK，酷~

11246
11:18:00,500 --> 11:18:05,630
Now, let's go ahead and try this out. Yarn hardhat. Test. 
现在让我们来试一下 `yarn hardhat test`

11247
11:18:05,630 --> 11:18:10,850
Oops, I spelled response wrong. Let's try that again. 
哎呀，我拼错了 `response`，来再试一次

11248
11:18:10,850 --> 11:18:14,960
Awesome. So this means that we are indeed assigning the price feed address correctly to the Mach v3 aggregator. 
太棒了，这就意味着我们确实正确地把 `priceFeed` 分配到 `mockV3Aggregator` 了

11249
11:18:14,990 --> 11:18:18,230
Okay, great. Awesome. 
OK，非常好，太棒了

11250
11:18:18,440 --> 11:18:21,080
I think for now, that's all we really want to do for our constructor. 
我想目前这些就是对构造函数所要做的所有事了

11251
11:18:21,080 --> 11:18:24,200
Now these two are kind of a nice to have, 
这两个东西也很不错

11252
11:18:24,200 --> 11:18:26,870
I showed them more just to kind of demo what they look like, 
但我展示它们只是为了演示它们是什么

11253
11:18:26,870 --> 11:18:29,420
we're going to skip writing tests for them for now. 
所以我们暂时不需要为它们编写测试

11254
11:18:29,420 --> 11:18:31,760
And we're actually going to go ahead and delete them directly from the contract.
我们直接把它们从合约中删掉

11255
11:18:32,090 --> 11:18:34,190
If you want to go ahead and write some tests for them 
如果你打算为它们编写测试

11256
11:18:34,190 --> 11:18:36,920
and leave them in your examples for your learnings. 
并把它们留在你的示例中以供学习的话

11257
11:18:36,920 --> 11:18:39,440
You absolutely can pause the video and write some tests for it if you choose so, 
你也可以暂停视频，编写测试

11258
11:18:39,440 --> 11:18:42,470
but we're going to skip them. 
但我会跳过它们

11259
11:18:42,470 --> 11:18:46,250
Next though, we are going to move on to fund and running some tests for fun here. 
接下来我们将移步到 `fund` 并为其运行测试

11260
11:18:46,250 --> 11:18:49,730
So let's go ahead and write describe fund. This will be an async function. 
所以我们来写下 `describe("fund", async function() {})`

11261
11:18:49,730 --> 11:18:55,730
And in here, we're going to do a number of tests. 
这里，我们将进行数个测试

11262
11:18:55,730 --> 11:18:58,760
So if we're going to go line by line here, 
如果我们要逐行测试这里

11263
11:18:58,760 --> 11:19:01,370
what's the first thing that we should look at? 
首先应该注意什么？

11264
11:19:01,370 --> 11:19:04,790
Well, we should look at this require line we should write a test to see if this contract


11265
11:19:04,790 --> 11:19:09,170
actually does fail? If not enough, eath is sent. So let's


11266
11:19:09,170 --> 11:19:15,680
go ahead and we'll say it fails, if you don't send enough eath


11267
11:19:17,030 --> 11:19:23,210
have this be an async function? Now, how do we test to see if


11268
11:19:23,210 --> 11:19:26,810
something fails? Right now we've done assert equals, but if


11269
11:19:26,810 --> 11:19:30,500
something fails, we might run into an issue. So for example,


11270
11:19:30,530 --> 11:19:36,290
if I run await fund me dot fund, but I don't pass any value to


11271
11:19:36,290 --> 11:19:39,410
this transaction. Let's see what happens. I run yarn Hardhead


11272
11:19:39,410 --> 11:19:44,720
test. Well, our test is actually going to break VM exception.


11273
11:19:44,930 --> 11:19:48,980
While processing transaction reverted with reason string, you


11274
11:19:48,980 --> 11:19:51,950
need to spend more eath. So our tests are going to break which


11275
11:19:51,950 --> 11:19:56,330
is good. We want this to break. But we want to tell our test


11276
11:19:56,330 --> 11:20:00,710
that this is okay. Right? Want to tell that this is okay. So


11277
11:20:00,860 --> 11:20:04,220
the way we can do this, and this is where our waffle testing


11278
11:20:04,220 --> 11:20:07,580
comes into play. With waffle and with testing, what we can


11279
11:20:07,580 --> 11:20:11,390
actually do is we can use the expect keyword and expect


11280
11:20:11,510 --> 11:20:15,080
transactions to be reverted and for transactions to fail. So


11281
11:20:15,080 --> 11:20:18,200
instead of using assert here, we're actually going to run a


11282
11:20:18,200 --> 11:20:28,310
wait expect fund me dot fun 2.2 dot B, that reverted and we've


11283
11:20:28,310 --> 11:20:31,340
actually even be more specific here by saying to be reverted


11284
11:20:31,430 --> 11:20:37,310
with and then the exact reverted error, you need to spend more


11285
11:20:37,340 --> 11:20:42,950
eath. Now if we run our tests, oops expect is not defined. So


11286
11:20:42,950 --> 11:20:47,570
we need to import that from Chai. Which chai is being


11287
11:20:47,600 --> 11:20:52,790
overwritten by waffle, we see that it does indeed Pass, which


11288
11:20:52,790 --> 11:20:57,860
is perfect. So now we have a way to both assert things and expect


11289
11:20:57,860 --> 11:21:01,310
things to fail. Awesome, even with the specific failure codes.


11290
11:21:01,580 --> 11:21:04,670
Perfect. Let's write some more tests here. Well, we probably


11291
11:21:04,670 --> 11:21:09,170
want it to correctly update this data structure. So we could say,


11292
11:21:09,680 --> 11:21:16,640
it updates the amount funded data structure, it's going to be


11293
11:21:16,640 --> 11:21:20,630
an async function. In here, we're going to need to call fund


11294
11:21:20,630 --> 11:21:25,070
v dot fund. However, we're going to need to actually pass some


11295
11:21:25,070 --> 11:21:29,180
value with this transaction. And for now, we'll just hard code


11296
11:21:29,180 --> 11:21:34,280
the value that we're going to send, say const. Send value is


11297
11:21:34,280 --> 11:21:40,070
going to be 112345 678-910-1234 5678, which


11298
11:21:40,070 --> 11:21:43,640
is going to be one eath. Another way we can write this though, is


11299
11:21:43,640 --> 11:21:46,790
we can use the ethers utility to make this a little bit easier to


11300
11:21:46,790 --> 11:21:49,610
read. Because all those zeros are kind of confusing, and it's


11301
11:21:49,610 --> 11:21:52,460
hard to tell at first glance what this actually is. So we're


11302
11:21:52,460 --> 11:22:00,980
gonna actually use ethers dot utils dot parse ether, one, this


11303
11:22:01,010 --> 11:22:05,570
parse ethers utility converts this one into that one with 18


11304
11:22:05,570 --> 11:22:08,870
zeros, which makes life a lot easier. If you go to the ethers


11305
11:22:08,870 --> 11:22:11,930
documentation, there's also a parts units function where you


11306
11:22:11,930 --> 11:22:16,250
can actually convert any unit, either ethers or Gwei. Or really


11307
11:22:16,250 --> 11:22:19,370
whatever you want to do, you could convert any number to any


11308
11:22:19,370 --> 11:22:22,130
other Aetherium you type. So this is the set value that we're


11309
11:22:22,130 --> 11:22:25,760
going to use for our fund. And, and this is definitely going to


11310
11:22:25,760 --> 11:22:30,830
be more than our minimum USD of 50. So after we call this fun


11311
11:22:30,830 --> 11:22:34,790
function, we'll say const response is going to be equal to


11312
11:22:34,850 --> 11:22:41,720
a weight, fund me dot address to Mt funded address to Mt funded


11313
11:22:41,990 --> 11:22:45,440
for the deployer dot address. Because remember, this is a


11314
11:22:45,440 --> 11:22:49,310
mapping of each address and how much they've actually funded. So


11315
11:22:49,310 --> 11:22:51,980
if we use the deployer address, it should give us the amount


11316
11:22:52,010 --> 11:22:55,130
that we actually sent. So now we can run assert dot equal


11317
11:22:57,020 --> 11:23:00,950
response.to string, right, because this response is going


11318
11:23:00,950 --> 11:23:04,880
to be the big number version of how much has been funded by that


11319
11:23:04,880 --> 11:23:08,570
account. And that should be the same as our send value.to


11320
11:23:08,570 --> 11:23:14,090
string. Since send value, our one should be the exact same as


11321
11:23:14,090 --> 11:23:17,690
the amount that we funded, we can run just this one test, or


11322
11:23:17,690 --> 11:23:23,090
running yarn, art hat, test, dash dash grep. And we'll put


11323
11:23:23,090 --> 11:23:28,970
this in quotes allow funded for this amount funded line. And it


11324
11:23:28,970 --> 11:23:32,630
looks like we ran into an issue here, because we don't need to


11325
11:23:32,630 --> 11:23:36,860
do deployed at address, we can just do deploy here. And great,


11326
11:23:36,890 --> 11:23:40,370
it looks like we are indeed passing. Now if we even run yarn


11327
11:23:40,370 --> 11:23:44,390
Hardhead coverage will now see we've got at least a little bit


11328
11:23:44,390 --> 11:23:47,570
more coverage here. It's still not going to be great. But we


11329
11:23:47,570 --> 11:23:50,270
have much better coverage. We have some statements, some


11330
11:23:50,270 --> 11:23:53,450
branches, and at least some functions covered. So this is


11331
11:23:53,450 --> 11:23:56,990
awesome. Let's keep going. Are we all done testing our fun


11332
11:23:56,990 --> 11:24:00,260
function? Well, probably not. What else can we do with our fun


11333
11:24:00,260 --> 11:24:03,230
function? Well, we're also adding funders to a funders


11334
11:24:03,230 --> 11:24:09,650
array. So let's go ahead and test for that. So it adds funder


11335
11:24:09,680 --> 11:24:17,540
to array of funders has been an async function. And we'll say


11336
11:24:17,570 --> 11:24:23,210
await fund mean that fund value is going to be send value. We'll


11337
11:24:23,210 --> 11:24:30,650
say const response equals await fund me dot calling the funders


11338
11:24:30,680 --> 11:24:38,030
array at index zero. So this will be funder equals await fund


11339
11:24:38,030 --> 11:24:41,930
me dot funders zero. And then we'll say assert dot equal


11340
11:24:42,680 --> 11:24:46,880
funder should be the same as the Deployer. So let's go ahead and


11341
11:24:46,880 --> 11:24:49,850
run this test. We'll hit up a couple times. And we'll change


11342
11:24:49,850 --> 11:24:56,990
the GREP to under to array so that it looks for this line. And


11343
11:24:56,990 --> 11:25:00,590
perfect. It looks like that one is also passing. Great. So the


11344
11:25:00,590 --> 11:25:03,890
money's coming through, the minimum amount is coming through


11345
11:25:03,920 --> 11:25:07,400
and our data structures are being updated. Awesome. Now we


11346
11:25:07,400 --> 11:25:10,340
could be a little bit more verbose and do even more testing


11347
11:25:10,340 --> 11:25:12,980
with this fun function. But I think for the most part, we've


11348
11:25:12,980 --> 11:25:16,280
got the gist, right. So now let's go ahead and move on to


11349
11:25:16,310 --> 11:25:18,800
the withdrawal function. So we're going to create a new


11350
11:25:18,800 --> 11:25:24,590
describe or withdraw. This is going to be an async function.


11351
11:25:26,150 --> 11:25:29,480
And let's see what the withdrawal function does. Only


11352
11:25:29,480 --> 11:25:32,120
the owner of the contract is going to be able to get the


11353
11:25:32,120 --> 11:25:36,170
balance, get the money back. And we're also going to reset all of


11354
11:25:36,170 --> 11:25:39,710
the amounts that each one of these users is done. So let's go


11355
11:25:39,710 --> 11:25:42,980
ahead and do some withdrawing. Now in order for us to test


11356
11:25:42,980 --> 11:25:47,630
withdraw, we probably first want the contract to actually have


11357
11:25:47,630 --> 11:25:51,230
some money and so what we can do actually is we can add another


11358
11:25:51,230 --> 11:25:55,250
before each in the describe to automatically fund the contract


11359
11:25:55,460 --> 11:26:01,430
before we run any tests. So we can say before each async


11360
11:26:01,430 --> 11:26:10,160
function. We can say await, fund me dot fund. Value, send value.


11361
11:26:10,820 --> 11:26:14,660
Now for all of our tests in this withdrawal scope, we're first


11362
11:26:14,660 --> 11:26:18,500
going to fund it with eath. Let's say it can withdraw,


11363
11:26:19,940 --> 11:26:26,300
withdraw eath. From a single founder, this would be an async


11364
11:26:26,300 --> 11:26:32,720
function. And this is going to be a little bit longer test. So


11365
11:26:32,750 --> 11:26:39,050
I'm going to set it up to be an arrange, act and assert test. So


11366
11:26:39,050 --> 11:26:42,290
arrange act assert is just sort of a way to think about writing


11367
11:26:42,290 --> 11:26:45,500
tests, you want to arrange the test, then you want to act. And


11368
11:26:45,500 --> 11:26:47,720
then you want to run the asserts, and you'll see what I


11369
11:26:47,720 --> 11:26:50,630
mean in just a second. So we're going to arrange this test,


11370
11:26:50,630 --> 11:26:53,360
we're going to set this test up, we want to actually check that


11371
11:26:53,360 --> 11:26:56,930
we're correctly withdrawing the ether from a single founder. So


11372
11:26:56,930 --> 11:26:59,360
first, we're going to get the starting balance of the


11373
11:26:59,360 --> 11:27:01,550
fundraising contract and the starting balance of the


11374
11:27:01,550 --> 11:27:08,090
Deployer. So we'll say const. Starting under me, balance,


11375
11:27:09,200 --> 11:27:16,340
equals await, fund me dot provider, dot get balance, fund


11376
11:27:16,340 --> 11:27:20,720
me dot address. So we're gonna start with the balance of the


11377
11:27:20,720 --> 11:27:24,470
fund V contract after it's been funded with some eath. And we're


11378
11:27:24,470 --> 11:27:29,840
also gonna get costs start starting, deploy your balance


11379
11:27:30,560 --> 11:27:37,790
goes await, fund me dot provider, dot get balance of


11380
11:27:38,360 --> 11:27:38,930
deployed employer.


11381
11:27:39,770 --> 11:27:42,410
So we're getting the starting balance of the Funmi, we're


11382
11:27:42,410 --> 11:27:44,930
getting to the starting balance of the employer so that we can


11383
11:27:44,960 --> 11:27:48,320
test later on how much these numbers have changed based off


11384
11:27:48,320 --> 11:27:50,750
of what happens when we call the withdrawal function. Now that


11385
11:27:50,750 --> 11:27:53,690
we've done a little bit of setup, we can actually run this


11386
11:27:53,690 --> 11:27:56,750
withdrawal function, we can do the act here. So we're gonna say


11387
11:27:56,750 --> 11:28:02,570
const, trans action response equals await, fund me dot


11388
11:28:02,570 --> 11:28:10,970
withdraw. And then we can say const, transaction receipt


11389
11:28:11,630 --> 11:28:19,520
equals await transaction response. That Wait, one, and


11390
11:28:19,520 --> 11:28:22,400
now we should be able to check to see that the entire fund


11391
11:28:22,400 --> 11:28:26,360
rebalance has been added to the deployer balance. So now we can


11392
11:28:26,360 --> 11:28:33,560
say const ending fund me balance equals a weight on me that


11393
11:28:33,560 --> 11:28:41,150
provider dot get balance of Unreal dot address. Then we can


11394
11:28:41,150 --> 11:28:49,460
say const ending deployer balance equals await, fund me


11395
11:28:49,610 --> 11:28:52,220
dot provider dot get balance


11396
11:28:54,080 --> 11:28:59,510
of Deployer. And now we can just check to see if the numbers work


11397
11:28:59,510 --> 11:28:59,900
out here.


11398
11:29:00,200 --> 11:29:09,770
So we can say assert dot equal ending fund me balance is going


11399
11:29:09,770 --> 11:29:13,070
to be zero, right, because we just withdrew all of the money.


11400
11:29:13,070 --> 11:29:16,940
So ending funding balance should be zero. And we'll say assert


11401
11:29:17,180 --> 11:29:25,880
dot equal starting fund me balance plus starting deployer


11402
11:29:25,880 --> 11:29:30,140
balance. So the starting funds the balance plus the starting


11403
11:29:30,170 --> 11:29:34,700
employer balance should equal the ending employer balance.


11404
11:29:34,730 --> 11:29:37,730
Since we're grabbing whatever the starting deployer balance


11405
11:29:37,730 --> 11:29:40,400
started with plus the starting fund to be balanced, because we


11406
11:29:40,400 --> 11:29:43,040
just withdrew all of the starting fund, we balance that


11407
11:29:43,040 --> 11:29:46,220
should equal the ending deployer bots. Now a couple of notes


11408
11:29:46,220 --> 11:29:48,830
here, since starting Funmi balance is calling from the


11409
11:29:48,830 --> 11:29:52,340
blockchain, it's going to be of type a big number, we want to


11410
11:29:52,340 --> 11:29:56,090
use big number dot add actually, instead of the plus sign here,


11411
11:29:56,120 --> 11:29:58,400
just because it'll it'll make working with our big numbers a


11412
11:29:58,400 --> 11:30:02,030
little bit easier. So instead of starting Funmi balance, plus


11413
11:30:02,060 --> 11:30:06,770
we're gonna be starting from the balance dot add. Like that. And


11414
11:30:06,770 --> 11:30:09,080
that should be good. One other thing about this, though, is


11415
11:30:09,080 --> 11:30:13,940
that when we called withdraw our Deployer did what our Deployer


11416
11:30:13,970 --> 11:30:20,510
spent a little bit of gas. So this actually isn't accurate. We


11417
11:30:20,510 --> 11:30:24,110
actually also need to calculate in the gas cost, so we wouldn't


11418
11:30:24,110 --> 11:30:29,930
need to do dot add gas cost. We'd also have to do.to string


11419
11:30:29,930 --> 11:30:34,340
because big numbers are objects and so identities a little bit


11420
11:30:34,340 --> 11:30:37,460
weird. So to test to see if they're equal, we'll just make


11421
11:30:37,460 --> 11:30:44,120
them both strings. 