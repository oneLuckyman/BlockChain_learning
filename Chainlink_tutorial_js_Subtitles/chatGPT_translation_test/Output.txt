稍后一点再说吧。
现在我们没有讨论到的是，什么是 nomic labs hard hat waffle？我们谈到了 Daddy 和 V-Hart 以及 Ether Scan 的 gas 报告。
那么今天，这是什么？我们可以通过谷歌搜索来找到 Hardhat waffle 的确切含义。
Hardhead waffle 实际上是与 waffle 测试框架一起使用的插件。
Waffle 是其中一个框架，它允许我们进行一些非常高级的测试，我们很快就要使用与这个非常相似的语法来工作了。
随着我们继续进行，我们会向您展示更多关于这个 waffle 工具的内容。
好的，本节下一部分，我将讲解 TypeScript 版本。
但是从所有方面来看，您已经成功创建了您的第一个 Hardhat 项目，您所做的一切都非常棒。
在这一课中，让我们对我们所学到的知识进行一个快速的复习，我们学会了如何启动我们自己的 Hardhat 项目。
现在我们可以运行 yarn hardhat 命令并查看 Hardhat 所提供的任务列表和其他不同的功能。
我们学会了 Hardhat 查找 hardhat.config.js 的方式，这是我们运行任何任务的入口点。

通过 Hardhat，我们学会了将智能合约添加到 contracts 文件夹中，并通过运行 yarn hardhat compile 进行编译，我们学习到所有的编译过程都会被放入到 artifacts 和 cache 中。
如果需要清除重置，我们可以删除这两个文件或者运行 yarn hardhat clean。
我们还学习到可以使用脚本或任务来部署、交互以及完成智能合约相关的工作。
我在这门课程中会一直使用脚本，但如果你愿意，你也完全可以使用任务。
我已经问了无数次这两者的区别，但没人真正清楚主要差别在哪里。
但我认为主要的区别在于，任务是为插件设计的，而脚本是为本地开发环境设计的。
我们学会了可以从 Hardhat 导入大量的内容，包括任务，并在脚本中使用异步函数来获取智能合约并将其部署。
我们甚至可以使用 Hardhat 和插件编程方式来验证部署的智能合约。
此外，我们还可以像使用 ethers 一样与智能合约进行交互。

我们编写了一个很棒的验证脚本，并且编写了我们的第一个测试任务。
我们展示了未来测试的样子，同时也讨论了它们的重要性。
我真的要强调编写好测试的重要性，这将是一个专业环境和一个普通项目的区别。
每当我审计智能合约或者有人给我一个项目让我来看看的时候，我首先看的是 readme。
当然，我看的第二件事就是测试。
如果测试不好，我会告诉他们“嘿，你需要重新构思一下，提高你的测试水平。
”所以测试真的非常重要，特别是在这个领域。
我们学习了一些更多的环境变量，学习了一些工具来查看我们测试的质量，其中一个是覆盖范围。
我们还学习了一个 gas 报告工具，以便在实际部署到真实网络时查看它将会花费我们多少。
我们深入学习了 hard hat 配置，以及如何在我们的 hard hat 上添加多个网络，我们可以让我们的项目适配这些不同的网络。

我们的 EVM 代码可以与任何网络配合使用，我们开始使用开发依赖而非常规依赖。
现在，READMEs（自述文件）并不是我要深入讨论的内容。
但是 READMEs 就像 GitHub 代码库的欢迎页面，应该能让你理解你的代码做了什么。
参与网络和区块链生态系统并不仅仅是你自己编写代码，你还希望其他人能够互动和参与你的代码和项目。
我还没有向你展示如何使用 GitHub。
但是不用担心，我们会的。
如果你看一下我的 Hardhat Simple Storage README，往下滑，你通常会发现一个入门部分，其中定义了如何设置所有代码以及如何设置所有内容的快速启动部分以及一些测试部分，这些部分教导人们如何实际使用和交互你的代码。
既然我们只是学习代码的一部分，而并不是 README 的部分，那么现在我们不会讨论如何制作一个完美的 README。
然而，我会在与本课程相关的 GitHub 代码库中留下一个链接。

链接到这个最好的自述文件模板。
这确实是一个非常好的自述文件模板，你可以复制到任何你的项目中，使它们看起来非常好，并给它们提供一个非常好的设置，这样其他开发人员就可以来到你的项目中学习和参与你的编码了。
但是，你已经学到了非常多的东西，你应该为自己感到非常自豪，并为自己已经走到了这一步而感到非常激动。
现在我要跳转到 TypeScript 部分。
所以，对于那些与 TypeScript 一起编码的人，随意跟随。
对于那些没有的人，你刚刚完成了在 hard hat 基础部分，但请留意下一个和再下一个部分，它们将是真正细致和磨练你技能的部分，并为你与这些框架一起工作提供所有基础知识。
所以务必跟随接下来的两个部分，我们还有更多棒极了的内容等着你，我们刚刚开始深入研究智能合约生态系统。
所以，喝口咖啡，我很快就会回来了。
好的，现在让我们使用 TypeScript 来做这件事。
所以我要从我们的 JavaScript 开始进行。

这一节。
然而，如果在将来，你想要开始一个新的 Hardhat 项目，你可以通过 "yarn hardhat" 开始一个新的项目，并做一些伟大且高级的 TypeScript 样例项目，你将添加许多插件。
然后你需要等一段时间才能上传所有东西。
你需要等待一段时间来下载所有东西。
虽然我们不会这样做，因为我将向你展示如何将其转换为 JavaScript。
无论如何，如果在将来的课程中，我们沿着 JavaScript 的编码进行，如果你想用 TypeScript 进行编码，那么你完全可以用它。
但是让我们来看看主要的区别在哪里。
那个高级的 TypeScript 东西会添加很多可能你不需要的包，在下一课中，我将讲解其中的一些。
但是有一些是你绝对需要的，比如 "typechain/ethers-v5"、 "typechain/hardhat"、 "TypeScript"、 "types/chai"、 "types/node"、 "types/mocha"、"TS node"、 "typechain" 和 "TypeScript"。
我在这门课所对应的 Github 仓库里提供了一个链接，里面有一个 "yarn add" 的命令。

可以直接复制粘贴，如果你想把它复制粘贴到你的项目中运行。
哎呀，我应该把这些添加为开发依赖项。
所以我们现在要把它们快速地转换成开发依赖项，只需要删除这两行，然后在这里加上一个逗号。
太好了，看起来好多了。
然后，当然，我们要把所有的 JavaScript 转换成 TypeScript。
所以无论在哪里看到 J S，我们都要改成 Ts。
显然，如果你一开始就用 TypeScript 写这个程序，你应该用 .ts。
这包括我们的 hardhat.config.ts，现在也要是 TypeScript。
此外，我们还要添加一个 tsconfig.json，这将成为我们的 TypeScript 配置。
通常，我们会使用类似这样的设置。
你可以从与本课程相关的 GitHub 存储库中复制它。
它基本上是告诉 TypeScript，要使用哪个版本的 TypeScript 和哪些文件来处理 TypeScript。
现在让我们从 deploy.ts 开始。
和往常一样，我们将使用 import 而不是 require，我们将做完全相同的事情。
我们将导入 ethers。

这里是代码转换和类型转换的部分，我们会把所有的 JavaScript 转换成 TypeScript。
如果你从头开始使用 TypeScript，你应该直接编写 .ts 文件。
这也包括我们的 hardhat.config 文件，现在也会使用 TypeScript。
此外，我们将添加一个 TS config.json 文件作为我们的 TypeScript 配置。
通常，我们需要按照以下格式进行配置。
你可以从与本课程相关联的 GitHub 仓库中复制。
这基本上告诉 TypeScript 版本以及要处理的文件。
现在，我们可以开始使用 deploy.ts。
和以往一样，我们将使用 import 而非 require。
我们做的事情完全相同。
我们将导入 ethers。

我们要从 Hardhat 运行网络。
然后在我们的验证函数中，我们将添加这些参数的类型。
所以合约地址将是一个字符串，args 将是一个参数数组。
因此我们将说它将是任意数组，因为它可能是字符串，也可能是数字，也可能是气球，也可能是任何东西。
我们还将说对于 IE，它可以是任意的，虽然这实际上是一个错误类型，但出于简单起见，我们只将其放为任意类型。
就现在而言。
我们的所有 TypeScript 脚本都包括在我们的 TS 配置中，或者任何 TypeScript 文件都是手动添加的，我们在这里有我们的整个脚本文件夹，这很好。
所以现在我们需要在这里添加 ethers 。
如果我们查看我们的 hardhat.config.ts，我们仍然在这里使用 require，我们需要将其更换成 import，对于 Donnie V，你可以使用 dot env / config 来抓取你的 dot env 文件。
现在我们导入了所有内容，返回我们的 deploy.ts，我们可以看到 linting 已经消失了。
如果您想更明确一些，我们还可以添加 import at nomic labs / hardhat ethers。
之所以我们不需要在这里导入它，是因为这两个包也适用于 Hardhat。

ethers会自动导入它，但是如果您想要更加明确，可以像这样添加。
现在，我们准备工作已经完成。
但是请记住，我们的Hardhat配置文件也导入了任务。
所以我们需要更新我们的任务或区块号码以使其TypeScript化。
当然，我们将从我们的config中导入任务，而不是使用const require。
并且我们要确保将我们的task作为默认导出。
所以我们可以像这样导出default task。
现在我们应该可以运行我们的脚本了。
我们只需要运行 "yarn hardhat run scripts employee.ts"，如果选择的话，我们可以添加 "--network hardhat"。
太棒了！现在到了测试的时候，事情就有些不同了。
让我们将这个"require"更改为"import"，以避免出现错误。
我们尝试运行"yarn hardhat test"，然后我们会收到一堆错误信息，在VS Code中，我们实际上可以从代码检查器中找到这些错误。
作为这个领域的开发人员，您可能遇到的最棘手的问题之一是在合约上调用不存在的函数，或者调用函数的方向错误。
现在，我们不是在调用不存在的函数，而是在已经存在的合约上调用不存在的函数。

我们的合约的类型很简单，只需要类型为 "contract"，但这并没有什么用，因为 "contract" 类型并不一定拥有我们想要的所有功能。
我们希望我们的合约是 "contract" 类型，但是我们希望它们是我们合约的类型，因为如果它们是我们合约的类型，它们就可以拥有我们想要的所有功能。
因此，为了给我们的合约正确的类型，我们实际上可以使用叫做 type chain 的工具，它可以给我们的合约提供正确的类型。
type chain 有一个叫做 hardened 的插件，允许我们原生地将 type chain 和 TypeScript 结合使用。
type chain / hard hat 就是我们已经安装的其中一个工具。
为了将它添加到我们的 hard hat 中，我们只需在 hard hat 配置文件中添加 "import typechain / hardhat"，然后在运行 yarn hardhat 后，我们现在会得到一个叫做 type chain 的新任务，我们可以生成类型化的合约并以此为每个合约都提供类型，在代码中我们可以定义一个简单存储 variable 类型为简单存储合约，这样会好很多，因为我们总是会知道我们能做些什么。

所以使用脚本是很棒的。
但如果我不想编写一个完整的脚本来做某些事呢？比如说我只是想用区块链做一个测试？那么 Hardhat 有一个自带的功能叫做“控制台”("console")。
控制台是一个 JavaScript 环境，用于运行 JavaScript 命令来和任何区块链进行交互。
我们可以通过以下命令跳转到控制台："yarn hardhat console" 后面可以是任何网络标识，比如说 Rinkeby, 主网络, polygon, avalanche 等等。
在这个 shell 里，我们可以做在 deploy 脚本里做的所有事。
因为 Hardhat 里的所有东西都已经在控制台里被自动导入了。
这是与所有区块链进行快速交互的一种很好的方式。
现在你可以通过按两次 "Ctrl C" 来退出 shell。
此外，这个控制台适用于所有网络。
比如说我们可以运行 "yarn hardhat console --network rinkeby"，就可以在 Rinkeby 上交互。
我们还可以部署合约，更新合约，以及做任何我们想要做的事情。
总之你可以在控制台里做任何事，它是对合约进行快速测试和交互的一种很好的方式。

