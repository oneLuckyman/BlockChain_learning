15843
16:07:41,330 --> 16:07:46,460
Alright, so now that we have our unit tests, let's go ahead and create a staging test. 
好的，现在我们已经完成了 "unit" 测试，让我们继续创建一个 "staging" 测试

15844
16:07:46,460 --> 16:07:50,270
Our staging test is going to look really similar to that massive test that we just created down here. 
我们的 "staging" 测试和我们刚刚创建的这一大堆测试很像

15845
16:07:50,300 --> 16:07:53,510
And the reason we set up our unit test to do this a weight promise thing with the raffle dot once
这也是我们设置 "unit" 测试执行这个 `await Promise raffle.once` 的原因

15846
16:07:53,510 --> 16:07:56,660
was because this is actually how we're going to need to wait on a test net or main net for a winner to be picked. 
因为这实际上才是我们在测试网或主网上等待优胜者被选出来的方式

15847
16:07:56,660 --> 16:07:59,780
We cannot on an actual test net, pretend to be the chain link V REF, 
我们无法在一个实际的测试网上假装成一个 "Chainlink VRF" 

15848
16:07:59,840 --> 16:08:02,480
we can pretend to be the chain link keepers if we want. 
如果我们愿意，我们可以假装成一个 "Chainlink Keepers" 

15849
16:08:02,480 --> 16:08:06,020
But we're not going to make sure that the 10 the keepers is actually working. 
但我们没办法确保这个 "Chainlink Keepers" 能实际运行起来

15850
16:08:06,050 --> 16:08:09,560
But we are going to be doing this because we want to listen for that event to be fired, 
但我们仍然会这样做，这是因为我们要监听 "event" 的触发

15851
16:08:09,560 --> 16:08:11,930
we want to listen for the chain link VRF to respond with the winner. 
我们希望能监听到 "Chainlink VRF" 对优胜者的回应

15852
16:08:11,930 --> 16:08:14,810
So let's create a staging test. 
好了，让我们来开始创建 "staging" 测试

15853
16:08:14,810 --> 16:08:17,300
And this is a test that we're going to run on an actual test net here. 
这次测试我们就要在一个真实的测试网上运行了

15854
16:08:17,300 --> 16:08:21,380
Okay, so we're going to create a new test called raffle dot staging dot test dot Jas 
我们来创建一个新的测试，名字就叫 `Raffle.staging.test.js`

15855
16:08:21,380 --> 16:08:25,760
and this is where we're going to put our staging test. 
这里就是我们放置 "staging" 测试的地方

15856
16:08:25,760 --> 16:08:29,180
Now we can actually code this pretty quickly because most of our staging tests is gonna look real similar to our raffle test here. 
我们写代码的速度可以很快，因为大多数 "staging" 测试的内容和 "Raffle.test" 的内容很相似

15857
16:08:29,210 --> 16:08:33,650
So for now, let's just grab this whole first part, 
现在，让我们先获取整个的第一部分

15858
16:08:33,650 --> 16:08:38,090
and then we'll adjust it as we need. 
然后我们会根据需要进行调整

15859
16:08:38,090 --> 16:08:41,150
And then we'll close it off. 
把这里闭合好

15860
16:08:41,150 --> 16:08:44,210
Because we're definitely gonna need a raffle, we're not going to need a VRF coordinator mock 
我们肯定是需要 "raffle" 的，但我们不再需要 "vrfCoordinatorMock" 了

15861
16:08:44,210 --> 16:08:47,660
because again, we're not going to be using a mock. Since we're on an actual test net, 
因为我们不会用到 "mock"，我们是在一个真实的测试网上

15862
16:08:47,660 --> 16:08:51,290
we will need the raffle entrance fee, we will need Deployer, 
我们需要 "raffleEntranceFee"，我们需要 "deployer"

15863
16:08:51,290 --> 16:08:54,200
we will need a Deployer. And we might need the interval. 
我们需要一个 "deployer"，我们可能还会需要 "interval"

15864
16:08:54,200 --> 16:08:57,320
But let's delete it for now 
但我们暂时先把它删掉

15865
16:08:57,320 --> 16:09:00,080
we probably won't need the chain ID. So let's delete that as well. Awesome. 
我们大概也不需要 "chainId" 了，所以让我们把它也删掉，很好

15866
16:09:00,080 --> 16:09:02,510
Something that we want to keep in mind is that when it comes to our staging tests, 
我们要记住的是，当我们进行 "staging" 测试的时候

15867
16:09:02,510 --> 16:09:06,020
we only want our steam test to run when we're on a test. Net, 
我们只希望 "staging" 测试在测试网上运行

15868
16:09:06,020 --> 16:09:08,660
we don't need to run our unit tests because our unit tests aren't checking that compatibility with a test net, 
我们不需要再运行 "unit" 测试，因为我们的 "unit" 测试没有检查与测试网的兼容性

15869
16:09:08,660 --> 16:09:11,120
we want our unit tests to only run on a local network. 
我们希望我们的 "unit" 测试只在本地网络上运行

15870
16:09:11,120 --> 16:09:14,090
And we want our staging tests to only run on a test network. 
而 "staging" 测试我们只希望它运行在测试网上

15871
16:09:14,090 --> 16:09:17,060
This is where again, in our test, we're going to check to make sure what type of chain we're on. 
又一次，在我们测试中，我们需要检查并确认我们是在什么类型的链上

15872
16:09:17,060 --> 16:09:19,670
And oops, it looks like I already imported the development changes here. 
哦，看起来我们已经把 "developmentChains" 给导入进来了

15873
16:09:19,670 --> 16:09:22,280
So we're actually in our staging tests, we're going to check before we run any test what kind of network we're on. 
所以在 "staging" 测试中，我们在运行任何测试之前都需要检查一下我们在什么类型的网络上

15874
16:09:22,280 --> 16:09:25,460
So we're gonna say, if our development chains that includes network dot name, 
所以我们要写，如果我们在 `developmentChains.includes(network.name)`

15875
16:09:25,460 --> 16:09:29,120
we're gonna say if our development chains includes network to name, 
我们会说，如果我们的 "developmentChains" 包含 "network.name" 

15876
16:09:29,120 --> 16:09:32,420
so if the chain we're on is in the development chains, 
或者说，如果我们所在的链在 "developmentChains" 中

15877
16:09:32,420 --> 16:09:35,930
and again, we're going to use this ternary operator 
对了，我们会再次使用三元运算符

15878
16:09:35,930 --> 16:09:38,480
where we say, if we're on a development chain, do something. 
我们说的就是，如果我们在 "developmentChains" 上就做某些事

15879
16:09:38,480 --> 16:09:41,150
And then if we're not on a development chain, do something else. 
而如果我们不在 "developmentChains" 上，就做另一些事

15880
16:09:41,150 --> 16:09:44,870
If we are on a development chain, what are we going to do? 
如果我们在 "developmentChains" 上，我们该做些什么？

15881
16:09:44,900 --> 16:09:49,490
Well want to skip this 
我们会想要跳过这一部分

15882
16:09:49,700 --> 16:09:52,730
and we can actually skip this by putting in this describe dot skip. 
我们可以通过把这个 "describe.skip" 放进这里来实现跳过的功能 

15883
16:09:52,730 --> 16:09:55,760
And this will skip this whole section here. 
这样就会把这一整个部分都跳过去

15884
16:09:55,760 --> 16:09:58,490
And then we can say, if we are the development chain, go ahead and do our thing. 
然后我们可以说，如果我们不在 "developmentChains" 上，就继续执行这些内容

15885
16:09:58,490 --> 16:10:01,430
So this is some really nice syntax that allows us to skip our staging tests if we're on a local network. 
这是一种非常好用的语法，如果我们在本地网络上，我们就会跳过 "staging" 测试

15886
16:10:01,430 --> 16:10:03,680
And additionally, we can grab this syntax, go into our raffle dot test dot j s 
不止如此，我们还可以获取这部分语法，前往我们的 "Raffle.test.js"

15887
16:10:03,680 --> 16:10:06,860
where we have our unit tests and add the bang operator, which is the knot and hit Save. 
在我们的 "unit" 测试中，添加一个否定符号，也就是“非”，再保存一下

15888
16:10:06,860 --> 16:10:09,500
And now we're saying if we're not on a development chain, skip it 
现在我们说的就是，如果我们不在 "developmentChains" 上，就跳过

15889
16:10:09,500 --> 16:10:13,730
and only run this if we aren't in development chain. 
只有当我们在 "developmentChains" 上时，才运行这些内容

15890
16:10:13,760 --> 16:10:17,000
So this says run this only on a test net or main net. 
所以这个意思就是，只有在测试网和主网上才往下运行

15891
16:10:17,000 --> 16:10:20,120
And then this has run this only on a local network. 
而这个意思就是只有在本地网络上的时候才往下运行

15892
16:10:20,120 --> 16:10:23,930
Great. So we have a deployer which we're going to need. 
很好，我们获取了 "deployer"，这正是我们需要的

15893
16:10:23,930 --> 16:10:27,140
We are not going to need to deploy any fixtures 
我们不再需要 "fixture" 进行部署了

15894
16:10:27,140 --> 16:10:30,740
because we're going to run our deploy script and our contracts should already be deployed. 
因为我们会自己运行部署脚本，而我们合约应该已经部署好了

15895
16:10:30,740 --> 16:10:34,520
We will need a raffle we won't need a VRF coordinator mocks we can delete that 
我们需要一个 "raffle"，但不需要 "vrfCoordinatorMock" 了，我们可以删掉它

15896
16:10:34,520 --> 16:10:38,000
We will need the entrance fee, and we probably won't need the interval. 
我们需要 "entranceFee"，但不一定需要 "interval" 了

15897
16:10:38,000 --> 16:10:41,120
So we can go ahead and delete that too. 
所以我们同样把它删掉

15898
16:10:41,120 --> 16:10:44,090
Alright, awesome. So we have our describe, we have our before each, let's make our tests. 
好的，现在我们有了 "describe" 还有了 "beforeEach"，让我们开始创建测试吧

15899
16:10:44,120 --> 16:10:47,660
And I'm just going to make one giant test to test kind of everything end to end. 
我们要做一个特别大的测试，完整的测试这里所有的内容

15900
16:10:47,660 --> 16:10:50,300
And you can add more tests later on yourself, if you want to 
如果你想的话，可以之后自行添加更多的测试

15901
16:10:50,300 --> 16:10:54,020
our staging test is going to be really similar to this massive test that we made down here. 
我们的 "staging" 测试和我们在这里做的这个大测试很像

15902
16:10:54,020 --> 16:10:57,320
And in fact, we're going to use most of this code here as our boilerplate. 
事实上，我们会大量使用这里的代码来作为我们的样板

15903
16:10:57,320 --> 16:11:00,740
So let's create a describe. And we'll say, 
我们来创建一个 "describe" 然后我们说

15904
16:11:00,740 --> 16:11:03,530
and we'll actually just copy this describe the four random words and paste it in here. 
我们直接复制这里的 `describe("fulfillRandomWords")`，并把它粘贴到这里

15905
16:11:03,530 --> 16:11:05,780
Because again, we're going to be using a lot of the same code in our staging tests here. 
我们会在 "staging" 测试这里大量复用代码

15906
16:11:05,780 --> 16:11:08,390
Great. So now we'll say it works with live chain link keepers and chain link VRF, 
好的，现在我们写 `it("works with live Chainlink Keepers and Chainlink VRF")`

15907
16:11:08,390 --> 16:11:11,360
we get a random winner, acing function. 
`"we get a random winner", async funciton()`

15908
16:11:11,360 --> 16:11:15,650
So this is going to be our test in here.
这就是我们在这里的测试了

15909
16:11:15,650 --> 16:11:18,620
So in this test, we of course, we want to enter the raffle. 
在这个测试中，我们当然是，先进入抽奖

15910
16:11:18,620 --> 16:11:22,100
And we shouldn't have to do anything else except for enter this raffle. 
我们什么都不用做，只要进入抽奖就可以了

15911
16:11:22,100 --> 16:11:25,190
Because the chain the keepers and the only VRF are going to be the ones to actually kick off this lottery for us, 
因为 "Chainlink Keepers" 以及 "VRF" 才是为我们开奖的存在

15912
16:11:25,190 --> 16:11:27,890
we'll do a quick grabbing of the starting timestamp to have it before all this kicks off. 
在这一切开始之前，我们会快速获取一下初始的时间戳

15913
16:11:27,890 --> 16:11:31,190
So we'll say const starting timestamp equals await raffle dot get last to me get latest timestamp, get latest timestamp, 
我们写 `const startingTimeStamp = await raffle.getLatestTimeStamp`

15914
16:11:31,190 --> 16:11:34,340
we're gonna grab this because later on, we're going to test to see if the timestamp has indeed moved forward, 
我们需要获取这个，因为一会儿我们要测试一下时间戳是否确实往前移动了

15915
16:11:34,340 --> 16:11:36,920
we want to enter the lottery, right, we want to run the command we've been running over here all the time, 
我们要进入抽奖，并且要运行我们一直在运行的这些指令

15916
16:11:36,920 --> 16:11:42,050
we want to do you know await raffle dot enter raffle, 
我们要做的是，就是`await raffle.enterRaffle()`

15917
16:11:42,290 --> 16:11:48,590
but we don't want to call it yet. 
但我们暂时还不想调用它

15918
16:11:48,650 --> 16:11:53,390
Because same as what we did over here, we want to set up our listener first. 
因为就和我们在这里做的一样，我们要先设置我们的 "listener" 

15919
16:11:53,450 --> 16:11:57,680
Now in here, we probably should have set up our listener before we entered the raffle. 
在这里，我们应该在进入抽奖之前就把我们的 "listener" 设置好

15920
16:11:57,680 --> 16:12:01,310
However, we controlled the blockchain. So putting it in that order was is was okay. 
然而，这里我们控制住了区块链，所以按这个顺序是可以的

15921
16:12:01,310 --> 16:12:03,890
But we want to set up the listener before we enter the raffle 
但现在我们要在进入抽奖之前就把 "listener" 给设置好

15922
16:12:03,890 --> 16:12:06,710
just in case the blockchain moves really fast. 
以防区块链运行的太快了

15923
16:12:06,740 --> 16:12:10,040
And we're going to set up the listener the exact same way, we did it over here. 
我们会以与之前完全相同的方式来设置 "listener" 

15924
16:12:10,040 --> 16:12:13,430
So we're gonna say await new promise. And it's going to be an async function that takes a resolve and a reject. 
所以我们写 `await new Promise(async (resolve, reject))`

15925
16:12:13,430 --> 16:12:19,700
And we're going to use a little arrow notation here. 
然后我们要在这里使用箭头符号 `=>`

15926
16:12:20,540 --> 16:12:23,780
And in here, we're going to set up the listener, 
我们就在这里设置 "listener" 

15927
16:12:23,780 --> 16:12:26,240
we're gonna say raffle dot once, once that winner is picked, 
我们写 `raffle.once("WinnerPicked")`

15928
16:12:26,300 --> 16:12:29,030
we're going to do another async function using that Arrow. Arrow function syntax, 
这里又是一个 `async` 函数，使用箭头函数语法

15929
16:12:29,030 --> 16:12:31,730
we'll say console dot log winner picked the event fired. 
我们接着写 `console.log("WinnerPicked event fired!")`

15930
16:12:31,760 --> 16:12:35,840
And only once we get this winner picked, can we start doing our asserts in here, 
只有当我们获取到了这个 "WinnerPicked"，我们才开始执行这里的 "assert" 

15931
16:12:35,840 --> 16:12:39,020
can we start making sure that there's a winner, there's a verifiably random winner, it's been picked, the money has been moved, etc. 
我们要确保已经有一个优胜者，被验证过的优胜者，被选了出来，资金才会发生转移等等

15932
16:12:39,020 --> 16:12:43,580
This is where we'll do our try catch. 
这里我们再执行 `try-catch`

15933
16:12:43,580 --> 16:12:46,580
And if there's any error, we're just going to automatically reject, we're going to reject the promise. 
只要出现任何错误，我们就自动返回 `reject` 这样就会拒绝这个 "Promise"

15934
16:12:46,580 --> 16:12:50,030
And if all goes well, of course, we're going to resolve the promise. 
而如果一切运行良好，我们当然就会 `resolve` 这个 "Promise"

15935
16:12:50,030 --> 16:12:53,930
So our listener has been set up here. We haven't added our asserts here. 
我们这里的 "listener" 已经设置好了，但还没有添加相应的 "assert" 

15936
16:12:54,050 --> 16:12:58,670
But we will, let's just go ahead and write the rest of the test. 
我们之后会添加的，不过让我们先继续编写测试的剩余部分

15937
16:12:58,760 --> 16:13:01,520
And then we'll go back and we'll update this listener so 
之后我们会返回来，然后再更新这里的 "listener"

15938
16:13:01,520 --> 16:13:05,090
so our listener has been added. 
这样我们的 "listener" 就已经添加好了

15939
16:13:05,090 --> 16:13:08,210
And inside here is actually where we're going to enter the raffle.
并且这里就是我们进入抽奖的地方

15940
16:13:08,210 --> 16:13:11,840
So inside here, await, raffle dot enter raffle value is going to be raffle entrance fee. 
所以这里就是 `await raffle.enterRaffle({value: raffleEntranceFee})`

15941
16:13:11,840 --> 16:13:14,450
And really that's it. Right? 
这就搞定了，对吧？

15942
16:13:14,450 --> 16:13:18,170
So we're setting up the listener, setting up the listener, then entering the raffle. 
我们设置了 "listener"，设置了 "listener"，然后进入了抽奖

15943
16:13:18,170 --> 16:13:21,890
And this code won't complete until our listener has finished listening 
并且直到我们的 "listener" 完成监听，代码才会完成

15944
16:13:21,890 --> 16:13:22,730
because again, this whole SEC is in a wait. 
因为这一整个部分都处于等待状态

15945
16:13:24,289 --> 16:13:29,389
So we're gonna say okay, cool setup, the listener, wait for this to finish. 
我们就像是在说，OK 设置 "listener"，等待这个完成

15946
16:13:30,469 --> 16:13:35,359
And then when it gets here, it goes out okay, this is the end of the code 
当它抵达这里的时候就说，OK 这里就是代码的结尾

15947
16:13:35,359 --> 16:13:38,959
Are we all done executing Oh, no resolve or reject hasn't been called yet. 
但我们完成运行了么？不，还没有，"resolve" 或 "reject" 都还没有被调用呢

15948
16:13:38,989 --> 16:13:42,349
And that's because we're still waiting for the listener to finish listening. 
因为我们仍然在等待 "listener" 完成监听

15949
16:13:42,349 --> 16:13:44,749
Now, once we get this winner picked event emitted in here, we're going to get that recent winner 
现在，一旦我们得知这里的 "WinnerPicked" 被触发了，我们就获取 "recentWinner"

15950
16:13:44,749 --> 16:13:49,549
so we'll say const recent winner equals await raffle dot get recent winner
所以我们要写 `const recentWinner = await raffle.getRecentWinner()`

15951
16:13:49,579 --> 16:13:52,519
will get the raffle state we'll say const. raffle state equals await raffle dot get raffle state, 
我们还要获取抽奖状态，这样写 `const raffleState = await raffle.getRaffleState()`

15952
16:13:52,519 --> 16:13:56,029
we'll get the winners balance. So we'll say const. Winner balance equals await recent winner. 
还有优胜者的余额，也就是 `const winnerBalance = await recentWinner`

15953
16:13:56,029 --> 16:13:58,609
And since we're only entering with our Deployer
由于我们只是用 "deployer" 进入了抽奖

15954
16:13:58,609 --> 16:14:01,579
we should check to see the deployers balance at the end 
所以我们应该检查 "deployer" 结束时的余额

15955
16:14:01,579 --> 16:14:04,699
and we can't do it right with this deployer object here. 
但我们无法直接应用这里的 "deployer" 对象

15956
16:14:04,729 --> 16:14:08,089
So we'll have to do the player account equals await ethers dot get signers, 
所以我们必须这样做 `const deployerAccount = await ethers.getSigners()`

15957
16:14:08,089 --> 16:14:10,789
no wrap this actually actually will just say this is accounts here like that. 
其实没有这个括号，并且这里应该是 `accounts`

15958
16:14:10,819 --> 16:14:17,329
And then we'll just do a count of zero because it counts as zero is going to be our Deployer. 
接着我们在这里执行 `accounts[0]`，因为 "accounts[0]" 就是我们的 "deployer" 

15959
16:14:17,329 --> 16:14:23,539
So our winner balance is going to be accounts a zero dot get balance. 
所以 "winnerBalance" 就是 `accounts[0].getBalance()`

15960
16:14:23,539 --> 16:14:26,509
And then we're going to do const ending timestamp equals a weight raffle dot get latest To timestamp, 
接着我们执行 `const endingTimeStamp = await raffle.getLatestTimeStamp()`

15961
16:14:26,539 --> 16:14:33,079
and we should also get the starting balance. 
我们还应该获取初始余额

15962
16:14:33,079 --> 16:14:37,009
So we'll say winner ending balance,
所以这里要改成 `winnerEndingBalance`

15963
16:14:37,009 --> 16:14:40,579
we should also get the starting balance right after we enter. 
同时，我们应该在进入抽奖之后就记录初始余额

15964
16:14:40,669 --> 16:14:43,309
So we'll say const. Winner, starting balance equals await accounts. Zero dot get balance, 
所以我们写 `const winnerStartingBalance = await accounts[0].getBalance()`

15965
16:14:43,339 --> 16:14:46,519
so that now we can do some comparisons. All right, great. Let's do the comparisons now. 
现在我们就可以进行比较了，那么就让我们开始比较吧

15966
16:14:46,579 --> 16:14:50,359
So we should first expect the raffle to be reset. 
首先我们应该预期抽奖已经被重置了

15967
16:14:50,359 --> 16:14:52,219
So we can do this a few different ways. Down here. We did number of players.
我们有几种不同的方法可以使用，拉到下面，这里有一个 "numPlayers"

15968
16:14:52,219 --> 16:14:56,179
We can also say, await, expect raffle dot get player 0.2 dot v dot reverted, right 
我们可以这样写 `await expect(raffle.getPlayer(0)).to.be.reverted` 对吧？

15969
16:14:56,179 --> 16:14:58,999
because Get Player zero should get reverted
因为 "getPlayer(0)" 应该已经被回滚了

15970
16:14:59,509 --> 16:15:04,939
because there's not even going to be an object at zero. 
因为 0 处不应该有任何对象了

15971
16:15:05,749 --> 16:15:09,979
So that's another way we can check to see if our players array has been reset. 
还有另一种方式可以检查我们的 "players" 数组是否已经被重置了

15972
16:15:10,009 --> 16:15:14,509
Next, we can do assert dot equal recent winner.to string, 
我们可以执行 `assert.equal(recentWinner.toString())` 

15973
16:15:14,509 --> 16:15:19,999
this should equal our account zero dot address. Okay, our Deployer 
它应该等于我们的 `accounts[0].address`，也就是我们的 "deployer"

15974
16:15:21,139 --> 16:15:25,339
What else can we do? 
我们还可以怎么做？

15975
16:15:25,369 --> 16:15:28,849
We will assert dot equal raffle state to zero. 
我们可以 `assert.equal(raffleState, 0)`

15976
16:15:28,849 --> 16:15:31,909
We want this email to go back to open after we're done. 
我们希望这个枚举值在运行完之后重回开放状态

15977
16:15:31,909 --> 16:15:37,999
And then we finally want to make sure that the money has been transferred correctly. 
最后我们想要确保一下资金已经被正确转账了

15978
16:15:38,059 --> 16:15:42,259
So we'll do assert dot equal, this should be a winner ending balance. That to string 
所以我们要执行 `assert.equal(winnerEndingBalance.toString())`

15979
16:15:43,069 --> 16:15:46,459
should be equal to winner starting balance, add raffle entrance fee.to string. 
它应该等于 `winnerStartingBalance.add(raffleEntranceFee).toString()`

15980
16:15:46,459 --> 16:15:49,369
So if we look down here, they enter the raffle we check their starting balance right after they enter. 
我们拉到下面这里，他们进入抽奖，我们检查他们在进入之后的初始余额

15981
16:15:49,369 --> 16:15:52,369
And they basically should just get that raffle entrance fee back right 
它们应该能直接把 "raffleEntranceFee" 给收回来，对吧？

15982
16:15:52,369 --> 16:15:57,259
because they are the only ones who have entered this raffle. 
因为其实只有一个人进入到了这个抽奖中

15983
16:15:57,289 --> 16:16:04,429
And then we can do one more assert, do assert that the ending timestamp is greater than the starting timestamp. 
接下来我们可以再执行一个 `assert(endingTimeStamp > startingTimeStamp)`

15984
16:16:04,429 --> 16:16:08,179
And then we'll of course, say resolve. 
然后，当然就是 `resolve()`

15985
16:16:08,419 --> 16:16:12,409
So this all goes well, we resolve. 
也就是这些全部都满足，我们就返回 "resolve"

15986
16:16:12,409 --> 16:16:17,839
If there's an issue with any of these asserts, we're going to catch those errors and we're going to reject 
如果这里面有任何一个 "assert" 出了问题，我们就 "catch" 这个错误并返回 "reject" 

15987
16:16:18,019 --> 16:16:23,569
and this is going to be false. And this whole test is gonna go ah, there was an issue, 
接着这里就会收到 false 并且整个测试都会收到，啊，这里出现问题了

15988
16:16:23,569 --> 16:16:26,569
staging test that looks really good here. Let's try this out. 
目前 "staging" 测试看起来一切良好，让我们来试试它吧