10343
10:21:03,320 --> 10:21:09,920
Now, how do we actually deploy this fund me contract? 
现在，我们该如何部署这个 "FundMe" 合约呢？

10344
10:21:09,920 --> 10:21:12,590
Well, let's think about this for a little bit.
让我们来仔细考虑一下这个问题

10345
10:21:12,830 --> 10:21:15,260
When working with remix, it was pretty easy, right? 
当我们使用 Remix 的时候，这是件很简单的事，对吧？

10346
10:21:15,260 --> 10:21:18,830
We just deployed it to a test net. 
我们只要直接把它部署到测试网络上就行了

10347
10:21:18,830 --> 10:21:21,590
Ah, that's kind of the issue there, isn't it 
啊，但这就是问题所在不是么？

10348
10:21:21,590 --> 10:21:24,680
deploying to a rink, the test net is a little bit slow. 
部署到 Rinkeby 测试网上实在是有点慢

10349
10:21:24,680 --> 10:21:27,920
We don't always want to have to deploy to one of these slow test nets or even a main net 
我们不想总是在这些慢速的测试网或主网上进行部署

10350
10:21:27,920 --> 10:21:31,010
when tinkering and fiddling with our contracts, do we 
从而调试和修改我们的合约，是吧？

10351
10:21:31,010 --> 10:21:34,700
know that's gonna be really bad, 
是的，那真的很糟糕

10352
10:21:34,700 --> 10:21:37,580
we really want to deploy to a test net as a last stop after we've done all our testing locally. 
我们想要的是将部署测试网这一步作为本地测试之后的最后一步

10353
10:21:37,580 --> 10:21:41,450
Or we can deploy it to a test that to see some very specific code work, 
或者我们可以提前将其部署到测试网络以查看某些特定代码如何工作

10354
10:21:41,450 --> 10:21:44,870
like for example, with the chain link documentation. 
例如与 Chainlink 文档一起使用

10355
10:21:44,870 --> 10:21:48,020
So ideally, we deploy this to a local network first. But can we just do that? 
理想情况下，我们应当首先部署到本地网络上，但我们真的可以直接这样做么？

10356
10:21:48,020 --> 10:21:51,260
Well, if we look in our price converter, dot Seoul, 
如果查看一下我们的 "PriceConverter.sol"

10357
10:21:51,260 --> 10:21:55,220
we have this hard coded address in here, this 0x address, 
我们会发现这里有一处硬编码地址，就是这个 0x 地址

10358
10:21:55,220 --> 10:21:59,570
if we go to Doc's dot chain that link EVM chains, contract addresses for Aetherium data feeds. 
如果我们前往 "docs.chain.link"->"EVM Chains"->"Contract Address"->"Ethereum Data Feeds"

10359
10:21:59,570 --> 10:22:03,560
That address is the eth USD, specifically for Rinkeby. 
那个地址是 "ETH USD" 的地址，具体来说是 Rinkeby 的

10360
10:22:03,560 --> 10:22:07,400
What if we work on the Hard Hat Network? 
如果我们想在 "Hardhat Network" 上运行呢

10361
10:22:07,580 --> 10:22:08,630
Example? default network? Hard Hat. 
比如说 `defaultNetwork: "Hardhat"`

10362
10:22:10,010 --> 10:22:13,250
And then like I said before, 
就像我之前说的

10363
10:22:13,250 --> 10:22:16,640
if you don't write this in part, it is automatically the default network. 
如果你这里不明确指定，那么 "hardhat" 将自动作为默认网络使用

10364
10:22:16,640 --> 10:22:19,430
But if we're to point to the Hard Hat Network, 
但如果我们就要指向 "Hardhat Network"

10365
10:22:19,430 --> 10:22:21,860
harder network is a blank blockchain. 
"Hardhat Network" 是一个空白的区块链

10366
10:22:21,860 --> 10:22:24,950
And it gets destroyed every time our scripts finish, 
每次我们的脚本运行完毕后它都会被销毁

10367
10:22:24,950 --> 10:22:28,220
or even if we're working with a local node, 
又或者即使我们在本地节点上工作

10368
10:22:28,220 --> 10:22:31,880
this price feed contract won't exist, 
这个喂价 (price feed) 合约也都是不存在的

10369
10:22:31,880 --> 10:22:34,550
one of the code there won't be updated with data. So what do we do? 
其中某些代码将无法更新数据，那么我们该怎么办？

10370
10:22:34,550 --> 10:22:36,770
How do we test and interact with our code locally? Is there a way we can do this? 
我们该如何在本地测试中与我们的代码进行交互？有没有什么方式可以做到这一点？

10371
10:22:36,770 --> 10:22:39,920
Well, one of the ways that we can do this that we'll learn a little bit later 
嗯，之后我们会学习一种方法

10372
10:22:39,920 --> 10:22:42,920
is actually forking a blockchain, where you can keep stuff hard coded. 
就是所谓的分叉(fork)一个区块链，你可以在其中保留硬编码内容

10373
10:22:42,920 --> 10:22:46,370
But usually, it's still better to figure out how to do everything with something called mocks. 
但通常来说，最好的方法还是使用一种被称为 "mocks" 的方法来完成所有的操作

10374
10:22:46,370 --> 10:22:49,460
There's a great Stack Overflow question that just says, What is mocking
这里有一个很好的 "Stack Overflow" 问题问的就是，什么是 Mocking？

10375
10:22:49,520 --> 10:22:52,550
and mocking is primarily used for unit testing, which we'll talk about in a little bit. 
mocking 主要用于单元测试，我们稍后会详细讨论

10376
10:22:52,550 --> 10:22:55,880
And object under test may have dependencies on other complex objects. 
受测对象可能依赖于其它复杂的对象

10377
10:22:55,880 --> 10:22:59,480
To isolate the behavior of the object, 
为了隔离某些对象的行为

10378
10:22:59,480 --> 10:23:03,860
you want to replace other objects by mocks that simulate the behavior of the real objects. 
你需要使用 mocks 对象来替换其它对象，以模拟真实对象的行为

10379
10:23:03,890 --> 10:23:07,490
In short, mocking is creating objects that simulate behavior of real objects. 
简而言之，mocking 就是创建一个模拟真实对象行为的对象

10380
10:23:07,490 --> 10:23:10,490
Now, this might seem like a lot of words. 
看起来它说了很多东西

10381
10:23:10,520 --> 10:23:13,670
But basically, what we want to do is we want to make a fake price feed contract 
但基本来说，我们想要的就是一个虚拟的喂价合约

10382
10:23:14,090 --> 10:23:17,060
that we can use and we can control when working locally. 
以供我们在本地工作时能够使用并进行控制

10383
10:23:17,060 --> 10:23:20,330
So back here, I'm just going to leave a note in here saying, 
所以在这里，我会留下一条注释说

10384
10:23:20,360 --> 10:23:23,270
When going for local host or Hard Hat Network, we want to use a mock. 
当使用本地主机或 "Hardhat Network" 时，我们要使用 mock

10385
10:23:23,270 --> 10:23:30,350
Okay, great, well, we can use a mock 
OK 好，现在我们要使用 mock 了

10386
10:23:30,560 --> 10:23:33,800
and we'll learn how to make one of those in a little bit. 
之后我们将学习如何来创建一个 mock

10387
10:23:33,800 --> 10:23:36,110
Well, what happens when we want to change chains, 
但是当我们想切换链的时候会发生什么呢

10388
10:23:36,110 --> 10:23:42,290
for example, back in dots dot chain to link EVM chains, contract addresses, 
举个例子，回到 "docs.chain.link"->"EVM Chains"->"Contract Address"

10389
10:23:42,290 --> 10:23:46,490
there are a ton of different block chains that have price feeds on them. 
这里有很多不同的区块链它们都有喂价数据

10390
10:23:46,940 --> 10:23:50,150
And on each one of these blockchains, 
并且在这些区块链的每一个上面

10391
10:23:50,150 --> 10:23:53,840
the eth USD price feed is going to be a little bit different. 
"ETH/USD" 的喂价数据可能会有一点不同

10392
10:23:53,840 --> 10:23:56,060
For example, we're looking at ETH USD, 
比方说，如果你查看 "ETH/USD"

10393
10:23:56,060 --> 10:23:59,900
the address of eth USD for Aetherium main net 
以太坊主网的 "ETH/USD" 地址

10394
10:23:59,900 --> 10:24:03,740
is different from the address of eth USD for Rigby, 
与 Rinkeby 的 "ETH/USD" 地址是不同的

10395
10:24:03,740 --> 10:24:05,840
which makes sense, they're totally different contracts on different chains, 
这是有道理的，它们是不同链上完全不同的合约

10396
10:24:05,840 --> 10:24:08,150
they have very similar functionality. And they do nearly the exact same thing. 
它们有非常相似的功能，做的也几乎是完全相同的事

10397
10:24:08,150 --> 10:24:10,970
But they're still different. 
但它们仍然是不同的

10398
10:24:11,000 --> 10:24:13,580
We're also going to need a way for us to modularize or parameterize, this address in here, 
我们还需要一种方法来把这里的地址给模块化或参数化

10399
10:24:13,580 --> 10:24:18,230
so that no matter what chain we deploy to, 
这样无论我们部署到哪个链上

10400
10:24:18,230 --> 10:24:21,410
we don't have to change any of our code, 
我们都不需要改动任何代码

10401
10:24:21,410 --> 10:24:23,810
we can always have our code be exactly the same. 
这样我们的代码可以始终保持一致

10402
10:24:23,810 --> 10:24:26,180
And we don't have to come in here and like flip values and flip variables and stuff. So 
也就不需要到这儿来切换值和切换变量之类的

10403
10:24:26,180 --> 10:24:29,720
let's keep that all of that in mind as we write the rest of this. 
在我们编写接下来的代码时，我们需要牢记这一点

10404
10:24:29,720 --> 10:24:32,990
Now in order to parameterize. This,
现在，为了把它参数化

10405
10:24:33,170 --> 10:24:36,500
we actually want to prioritize and do a little refactoring of our fundamental soul. 
我们需要对我们的 "FundMe.sol" 进行一些重构

10406
10:24:36,500 --> 10:24:39,440
Refactoring basically means going back and, 
重构的意思基本上就是

10407
10:24:39,440 --> 10:24:43,370
and changing the way your code works. 
回过头去改变你代码的工作方式

10408
10:24:43,400 --> 10:24:46,340
Right now we have this constructor function, right 
现在我们拥有这个构造函数，对吧？

10409
10:24:46,340 --> 10:24:49,190
the constructor function is the function that automatically gets called whenever we deploy our contract. 
构造函数就是一个在我们部署合约时会被自动调用的函数

10410
10:24:49,220 --> 10:24:52,280
Right now it's not doing a whole lot 
目前它并没有做很多事情

10411
10:24:52,280 --> 10:24:55,040
right now it's just updating the owner variable to be whoever sent in the contract. 
现在它只负责把 "owner" 变量更新为合约的发送者

10412
10:24:55,040 --> 10:24:58,970
But we can actually have a do much more than that. 
但我们能做的远远不止这些

10413
10:24:58,970 --> 10:25:02,030
Since this constructor is a function just like every other function, we can actually have it take parameters, 
由于构造函数和其它函数一样，也可以接收参数

10414
10:25:02,030 --> 10:25:04,520
one of the parameters that we might like for it to have is going to be the address of a price feed. 
那么我们想让它接收的其中一个可能的参数就是价格数据的地址

10415
10:25:04,520 --> 10:25:07,250
So let's go ahead and add this and figure out how to refactor all this code. 
现在让我们添加这个参数，并搞清楚如何重构这些代码

10416
10:25:07,250 --> 10:25:11,270
So we're going to add constructor address, price feed for the constructor in here. 
所以我们要在 "constructor" 中添加一个 "address priceFeed"

10417
10:25:11,270 --> 10:25:13,220
When we deploy our contract. Now
现在，当我们部署合约时

10418
10:25:13,220 --> 10:25:17,900
we're going to pass it the eth USD price feed address depending on what chain we're on. 
我们将根据所在的链向它传递 "ETH/USD" 的喂价地址

10419
10:25:18,380 --> 10:25:21,500
If we're on rink B, we'll use this address 
如果我们在 Rinkeby 上，我们就要用这个地址

10420
10:25:21,530 --> 10:25:24,890
if one polygon will use a different one 
如果是 Polygon 就会用其它的

10421
10:25:24,890 --> 10:25:27,500
b&b, different one, Gnosis hecho, avalanche, etc, you get the picture. 
BNB 也是一个道理 Gnosis, HECO, Avalanche 等等，你应该懂了吧

10422
10:25:27,500 --> 10:25:30,470
So we're going to marginalize this like so. 
所以我们才要这样调整它

10423
10:25:30,470 --> 10:25:34,100
Now that our constructor takes a parameter for the price feed, 
现在我们的 "constructor" 要接收一个 "priceFeed" 参数

10424
10:25:34,100 --> 10:25:37,730
we can actually save an aggregator v3 interface object as a global variable 
那么我们就可以将 "AggregatorV3Interface" 保存为一个全局变量

10425
10:25:37,730 --> 10:25:40,700
in our price converter, 
在我们的 "PriceConverter" 中

10426
10:25:40,700 --> 10:25:44,420
we just create a price feed variable of type aggregator v3 interface, 
我们创建了一个 "AggregatorV3Interface" 类型的 "priceFeed" 变量

10427
10:25:44,420 --> 10:25:47,540
which again, we're importing from the chainlink repo, 
并且重申一下，我们是从 chainlink 的代码库中导入进来的

10428
10:25:47,540 --> 10:25:51,290
which is an interface object which gets compiled down to the ABI. 
它是一个 "Interface" 对象并且会被编译为 ABI

10429
10:25:51,290 --> 10:25:54,020
If you match an ABI with up with an address, you get a contract that you can interact with. 
如果你将 ABI 与某个地址匹配起来，就能获得一个可以与之交互的合约了

10430
10:25:54,020 --> 10:25:57,590
So we're going to do the same thing here. 
我们将在这里执行相同的操作

10431
10:25:57,590 --> 10:26:00,590
We're gonna say, aggregate Tor, v3 interface, public price feed,
我们要定义 "AggregatorV3Interface public priceFeed"

10432
10:26:00,590 --> 10:26:02,690
ration and call this price feed address 
这里得改成 "priceFeedAddress"

10433
10:26:02,690 --> 10:26:09,530
so that these don't have the same name. 
这样它们就不会重名了

10434
10:26:10,670 --> 10:26:13,940
And in our constructor, we're going to say price feed equals, 
在 "constructor" 中，我们要执行 "priceFeed = "

10435
10:26:13,940 --> 10:26:17,690
and we're going to do the exact same thing we did with our price converter 
接下来就和我们在 "PriceConverter" 中所做的完全相同

10436
10:26:17,690 --> 10:26:21,440
equals aggregate tore the three interface of price feed address. 
"= AggregatorV3Interface(priceFeedAddress)"

10437
10:26:21,470 --> 10:26:26,360
Like so 
就像这样

10438
10:26:26,360 --> 10:26:27,440
now, we have this price feed address 
现在我们就有了这个 "priceFeedAddress"

10439
10:26:28,580 --> 10:26:36,680
that's variable and modularized, depending on whatever chain that we're on. 
它是可变的也是模块化的，具体的值取决于我们在哪个链上

10440
10:26:36,680 --> 10:26:40,520
Now, what we can do is we can grab this price feed address, and we can use it for our price converter. 
现在，我们就可以获取 "priceFeedAddress" 并将其用于我们的 "PriceConverter" 了

10441
10:26:40,520 --> 10:26:44,030
So where are we using our price converter? 
那么我们要在哪里使用 "PriceConverter" 呢？

10442
10:26:44,030 --> 10:26:47,720
Well, just a quick reminder, we're using using price converter for you at 256. 
快速提醒一下，我们正在使用 "using PriceConverter for uint256"

10443
10:26:47,720 --> 10:26:51,170
We're using this as a library on top of our unit 256 type. 
我们将其作为一个 "library"，附着于 "uint256" 类型之上

10444
10:26:51,170 --> 10:26:55,550
So we're calling message dot value dot get conversion rate. 
所以我们要调用 "msg.value.getConversionRate"

10445
10:26:55,550 --> 10:26:59,690
So we look at our price converter, we have this function get conversion rate, 
查看一下我们的 "PriceConverter"，里面有这个 "getConversionRate" 函数

10446
10:26:59,720 --> 10:27:03,200
which takes an FML as its initial parameter,
它接收一个 "ethAmount" 作为初始参数

10447
10:27:03,200 --> 10:27:06,200
which again, since this is a library, 
再提醒一下，由于这是一个 "library"

10448
10:27:06,200 --> 10:27:09,860
it automatically passes the message dot value into this get conversion rate function.
所以它会自动将 "msg.value" 传递给 "getConversionRate" 函数

10449
10:27:09,860 --> 10:27:13,490
But we could also pass in this price feed, 
但我们可以同时传递这个 "priceFeed"

10450
10:27:13,490 --> 10:27:16,550
and therefore we wouldn't need to hard code it in the get price anymore. 
这样 "getPrice" 里就不再需要使用硬编码了

10451
10:27:17,150 --> 10:27:22,280
So let's go ahead and figure out how to do that. 
让我们来看一下如何实现这一点

10452
10:27:22,280 --> 10:27:25,640
Well, what we can do is we can do message dot value dot get conversion rate, 
我们需要做的是使用 `msg.value.getConversionRate` 

10453
10:27:25,640 --> 10:27:28,310
we'll stick price feed in here. 
并把 "priceFeed" 填入其中

10454
10:27:28,310 --> 10:27:31,430
And then we'll have to update our get conversion rate 
接着要更新我们的 "getConversionRate"

10455
10:27:31,430 --> 10:27:34,520
to do a comma so that it takes a second parameter, 
添加一个逗号，以使其接收第二个参数

10456
10:27:34,520 --> 10:27:38,240
because remember, again, the initial parameter is going to be message dot value. 
因为要记住，初始参数是 `msg.value`

10457
10:27:38,240 --> 10:27:41,960
And the second parameter is going to be what we define here. 
而第二个参数将是我们在此处定义的内容

10458
10:27:41,960 --> 10:27:44,540
So we'll do s amount, comma ag reg gate Tor v3 interface. 
所以我们写下 `ethAmount, AggregatorV3Interface`

10459
10:27:44,540 --> 10:27:50,210
And we'll call this price feed. 
并称其为 `priceFeed`

10460
10:27:50,210 --> 10:27:58,610
And now, when we call our get price function, 
现在，当我们调用 `getPrice` 函数时

10461
10:27:58,610 --> 10:28:03,680
we can pass the price feed to the get price function. 
就可以将 `priceFeed` 传递给 `getPrice` 函数了

10462
10:28:03,680 --> 10:28:07,430
And up here we can have get price. 
而在这里，我们可以定义 `getPrice`

10463
10:28:07,430 --> 10:28:14,420
Take, you guessed it an aggregate or the three interface called price feed. 
接收一个 `AggregatorV3Interface priceFeed`

10464
10:28:15,410 --> 10:28:22,220
And now we no longer need to hard code in the price feed. 
现在我们就再也不需要在 `priceFeed` 中使用硬编码了

10465
10:28:22,220 --> 10:28:25,430
And we can just delete those lines and have it compile like this, which is awesome. 
我们可以删掉这几行并直接进行编译，就像这样，这真是太棒了

10466
10:28:25,430 --> 10:28:30,020
So quick refresher, we're parameterizing that price feed address 
好，快速回顾一下，我们正在对 `priceFeed` 地址进行参数化处理

10467
10:28:30,170 --> 10:28:33,590
and passing it in with a constructor 
并将其传入构造函数中

10468
10:28:33,590 --> 10:28:37,250
that gets saved as a global variable to an aggregator v3 interface type, 
它被保存为一个 "AggregatorV3Interface" 类型的全局变量

10469
10:28:37,250 --> 10:28:41,570
or passing it to a get conversion rate function, 
并被传入一个 `getConversionRate` 函数

10470
10:28:41,570 --> 10:28:45,770
which passes it to the get price function, which then just calls latest round data. 
接着被进一步传入到 `getPrice` 函数，然后调用 `latestRoundData`

10471
10:28:45,770 --> 10:28:48,680
And we probably could have made this even easier, 
或许我们能让这一切变得更简单一些

10472
10:28:48,680 --> 10:28:50,720
probably could have just got rid of the get price function 
我们可以直接删除 `getPrice` 函数

10473
10:28:50,720 --> 10:28:54,080
and stuck this code in the get conversion rate. 
并把这些代码放进 `getConversionRate` 里

10474
10:28:54,080 --> 10:28:56,630
But we'll leave it there for now. 
但我们暂时先不做改动

10475
10:28:56,660 --> 10:28:59,630
Now that we've done that refactoring, let's make sure it works. 
现在我们已经完成了重构，让我们确保它能顺利工作

10476
10:28:59,630 --> 10:29:03,140
Yarn Hardhead, compile, invalid value undefined for hardhat dot config dot networks. 
`yarn hardhat compile`，未在 "HardhatConfig.networks" 中定义的无效的值

10477
10:29:03,140 --> 10:29:07,010
Let's go to the let's go to the config real quick.
让我们快速转到配置文件

10478
10:29:07,100 --> 10:29:09,860
That's because the default network needs to be outside of networks. My mistake. Let's try that again. 
这是因为 `defaultNetwork` 需要在 `networks` 的外部，是我的错，我们再试一次

10479
10:29:09,860 --> 10:29:14,300
I spelled interface wrong and the price converter. 
我把 "Interface" 拼错了，在 `PriceConverter` 里

10480
10:29:14,300 --> 10:29:17,360
And a quick note, if gives you an error like this, 
这里做个小说明，如果你像这样遇到了某个报错

10481
10:29:17,360 --> 10:29:20,750
oftentimes, you can command click or control click and open that file up right in the editor, 
通常你可以按住 "Command" 键单击或 "Ctrl" 键单击来在编辑器中把对应文件打开

10482
10:29:20,750 --> 10:29:23,930
which saves you some time, we're going to have defined the line and find the file. 
这样可以节省你的一些时间，也就不需要去找特定某个文件的某一行了

10483
10:29:23,930 --> 10:29:26,240
But yeah, let's spell that correctly. 
好的，让我们把拼写改正

10484
10:29:26,240 --> 10:29:29,540
And let's try this again. 
接着我们来再试一次

10485
10:29:29,540 --> 10:29:33,620
And awesome. It looks like it's compiling correctly. 
太棒了，看起来编译正确

10486
10:29:33,620 --> 10:29:36,560
And we just have some warnings, 
只是有一些警告("Warning")

10487
10:29:36,560 --> 10:29:39,560
it looks like these warnings are just about this git version, 
看起来这些 "warning" 是关于这个 `getVersion` 的

10488
10:29:39,560 --> 10:29:42,650
which is because we're shadowing this, we're creating a new price variable down here,
这是因为我们在这里创建了一个新的 `priceFeed` 变量

10489
10:29:42,920 --> 10:29:45,590
you've no we just created a global price free variable.
而我们刚刚又在这里创建了一个全局的 `priceFeed` 变量

10490
10:29:46,100 --> 10:29:48,200
Let's just go ahead and delete the get version function altogether 
我们把 `getVersion` 函数也删除掉

10491
10:29:48,200 --> 10:29:51,140
since we're not even going to really need it. 
因为我们根本不需要它

10492
10:29:51,140 --> 10:29:53,690
And we only use the Git version to show you how to actually start working with interfaces. 
我只是用 `getVersion` 来向你展示如何开始使用接口

10493
10:29:53,690 --> 10:29:56,480
And then we'll compile it one more time for good measure. 
让我们再编译一次以确保一切顺利

10494
10:29:56,480 --> 10:30:01,100
Boom compiled successfully. Awesome.
嘭，编译成功，太棒了

10495
10:30:01,130 --> 10:30:04,970
So now we've just refactored our code. 
我们刚刚已经重构了我们的代码

10496
10:30:04,970 --> 10:30:08,990
So we can pass a price feed address depending on the network that we're on. 
这样我们就可以根据我们所处的网络来传递 `priceFeed` 的地址了

10497
10:30:08,990 --> 10:30:12,320
Okay, great. With all that being said, let's come back to our deploy Funmi script, 
好，说了这么多，让我们回到 "deploy-fund-me" 脚本

10498
10:30:12,320 --> 10:30:15,110
and let's learn how to actually deploy the rest of it. 
继续学习如何部署它的其余部分

10499
10:30:15,110 --> 10:30:18,350
In order for us to deploy a contract 
为了部署这个合约

10500
10:30:18,350 --> 10:30:22,100
we remember from our last sections that we use the contract factories, 
上一部分我们使用了 `contractFactory`

10501
10:30:22,100 --> 10:30:25,640
with heart hit Deploy, we can just use this deploy function. 
通过 "hardhat deploy"，我们可以直接使用这个 `deploy` 函数

10502
10:30:25,640 --> 10:30:28,700
And to use the deploy function, 
要使用这个 `deploy` 函数

10503
10:30:28,700 --> 10:30:32,300
we'll say const Funmi, which is going to be the name of our contract, 
我们要写下 `const fundMe` 这是我们合约的名称 

10504
10:30:32,300 --> 10:30:36,200
equals await. And we'll call this deploy function, the name of the contract that we're deploying right now, 
`= await` 接着调用这个 `deploy` 函数，包含我们要部署的合约名称

10505
10:30:36,200 --> 10:30:39,710
and then a list of overrides that we want to add here. 
以及想要添加的覆盖选项的列表

10506
10:30:39,710 --> 10:30:42,650
So we're gonna say who is actually deploying this by saying from, 
通过指定 `from` 来确定是谁在进行部署

10507
10:30:42,650 --> 10:30:45,980
we're gonna say it's from the Deployer. 
我们将指定 `deployer` 为 `from` 的值

10508
10:30:45,980 --> 10:30:49,880
We're gonna pass any arguments to the constructor In this args piece here, 
我们会将任何需要传递给构造函数的参数放在 `args` 中

10509
10:30:49,880 --> 10:30:55,250
which we just added a single Argh. 
目前我们只传递了一个参数

10510
10:30:55,250 --> 10:30:57,530
So these brackets, we're going to make it a list of arguments, 
这个括号会使它成为一个参数列表

10511
10:30:57,530 --> 10:30:59,660
we're going to put the price feed address in here, 
我们要在这里放入 `priceFeedAddress` 

10512
10:30:59,660 --> 10:31:03,980
which we'll show you how to do in a second, put price feed address. 
我们马上就会展示如何做到这一点，“放入 price feed address ”

10513
10:31:03,980 --> 10:31:06,260
And then we're also going to do some custom logging here 
接着我们还要做一些自定义的日志

10514
10:31:06,260 --> 10:31:08,600
so that we don't have to do all that console dot log stuff that we've been doing this whole time. 
这样我们就不需要像之前那样总是用一堆 `console.log` 了

10515
10:31:08,600 --> 10:31:12,080
And we need to put something in here. 
我们需要在这里放置一些内容

10516
10:31:12,080 --> 10:31:15,290
We need to put an address in here. 
我们需要放在这里的是一个地址

10517
10:31:15,290 --> 10:31:17,600
And you can use this backslash star to put like a common in between your code.
你可以使用这个反斜杠星号("/*")在你的代码中放置注释

10518
10:31:18,950 --> 10:31:22,130
We can't just do const address equals, you know the address and stick it in here. 
我们不能直接用 `const address = `，因为你要把地址放到这里

10519
10:31:22,190 --> 10:31:24,740
Well, I mean, we could but we're not really prioritizing now. Right? 
好吧，我的意思是，可以这样做，但这样就不是真正的参数化了，对吧？

10520
10:31:24,740 --> 10:31:27,620
We're kind of back to just hard coding it here. 
这相当于我们又回到硬编码了

10521
10:31:27,620 --> 10:31:30,860
So what can we do instead? 
那我们该怎么做呢？

10522
10:31:30,860 --> 10:31:35,990
Well, what we can do is we can actually use the chain ID to do something like 
我们可以使用 "chainId"，来做一些像是这样的事

10523
10:31:35,990 --> 10:31:45,500
if chain ID is x, use address, Y, 
如果 "chainId" 是 "X" 则使用地址 "Y"

10524
10:31:45,500 --> 10:31:48,140
or if chain ID is Z use address A. 
或者如果 "chainId" 是 "Z" 则使用地址 "A" 

10525
10:31:48,140 --> 10:31:51,860
So we can do something that looks like this. 
那么我们可以做一些类似这样的事情

10526
10:31:51,890 --> 10:31:54,830
And to enable this functionality, we actually take a page out of the Ave GitHub. 
要想实现这个功能，我们需要借鉴 "aave" 的 GitHub

10527
10:31:54,830 --> 10:31:57,590
So Ave is another protocol that's on multiple chains 
"aave" 是存在于多个链上的一个协议

10528
10:31:57,590 --> 10:32:01,220
and has to deploy their code to multiple chains and work with multiple different addresses. 
所以它必须把代码部署到多个链上并使用多个不同的地址

10529
10:32:01,220 --> 10:32:04,070
So what they do is they use a number of different useful tricks. 
他们使用了多个不同的实用技巧

10530
10:32:04,070 --> 10:32:07,340
But one of the main ones is using this helper hardhat config. 
其中一个主要的就是使用这个 "helper-hardhat-config"

10531
10:32:07,340 --> 10:32:10,280
Now they're using TypeScript with JavaScript, but it's gonna be the same thing. 
他们用的是 TypeScript 我们用的是 JavaScript，但都是一样的

10532
10:32:10,280 --> 10:32:14,630
With this config, they have different variables, 
在这个 config 中，他们定义了许多不同的变量

10533
10:32:14,630 --> 10:32:17,690
depending on what network that they're actually on. 
具体取决于它们所依赖的网络

10534
10:32:17,690 --> 10:32:20,270
And depending on the network that they're on, they use different variables. 
根据所在网络的不同，他们使用不同的变量

10535
10:32:20,270 --> 10:32:24,020
So they use this network config almost to do exactly what we're trying to do here. 
他们使用的这个网络配置几乎完全做到了我们想要做的事情

10536
10:32:24,020 --> 10:32:27,710
So what we want to do is we're going to create a new file at the root directory, 
那么我们要做的就是，在根目录下创建一个新的文件

10537
10:32:28,250 --> 10:32:32,900
so just click down here, new file. 
点击这里，新建文件(New File)

10538
10:32:32,900 --> 10:32:39,170
And we're going to call it helper, hard hat config dot j, s. 
将其命名为 "helper-hardhat-config.js"

10539
10:32:39,170 --> 10:32:41,840
And this is where we're going to define that network config. 
这就是我们要定义网络配置的地方

10540
10:32:41,840 --> 10:32:43,940
And this is where we're going to say, hey, if you're on network, a, use this address 
也就是告诉它，嘿，如果你在网络 A 上，就用这个地址

10541
10:32:43,970 --> 10:32:48,050
network, be this use this address, etc. 
如果是网络 B 就是这个地址，等等等等

10542
10:32:48,080 --> 10:32:52,280
So we're going to create an object called const. Network config. equals 
现在我们就来构建 `const networkConfig =`

10543
10:32:53,000 --> 10:32:55,730
and we're going to add a bunch of stuff in here. 
然后在这里添加一大堆东西

10544
10:32:55,730 --> 10:32:58,700
So our main network that we're working with right now is rinky. dinky has a chain ID of four. 
现在我们使用的网络是 Rinkeby，Rinkeby 的 chainId 是 4

10545
10:32:58,700 --> 10:33:04,250
So we'll say chain ID four 
所以我们写下 chainId 4 

10546
10:33:04,310 --> 10:33:12,410
is going to be named Rinkeby. And the eth USD price feed address is going to be 
`name: "rinkeby"` 以及 `ethUsdPriceFeed` 地址是 

10547
10:33:12,410 --> 10:33:16,370
the price feed address of rank B of the eth USD price feed. 
Rinkeby "ETH/USD" 喂价数据的地址

10548
10:33:16,370 --> 10:33:19,190
So we're going to copied from the documentation or from the GitHub, whatever you want to do, 
我们把它从文档中复制下来，或者 GitHub 也行，随你便了

10549
10:33:19,190 --> 10:33:22,820
and paste it in here. 
然后粘贴到这里

10550
10:33:22,820 --> 10:33:26,000
Now we have a simple methodology of 
现在我们就有了一个简单的方法

10551
10:33:26,000 --> 10:33:29,270
keeping track of different price feeds a different contract addresses across different chains. 
来跟踪不同喂价数据在不同链上的不同合约地址

10552
10:33:29,270 --> 10:33:33,140
Let's say for example, we wanted to deploy to Polygon as well. 
举个例子，比如说我还想要部署到 Polygon 上

10553
10:33:33,170 --> 10:33:36,110
Well, first, what are we going to need? 
首先，我们需要什么？

10554
10:33:36,110 --> 10:33:39,590
Well, we're going to need the chain ID of polygon. 
我们需要的是 Polygon 的 chainId

10555
10:33:39,590 --> 10:33:43,040
So a quick little Google Search brings us to the polygon documentation. 
使用 Google 快速搜索一下，它会带我们去到 Polygon 的文档

10556
10:33:43,040 --> 10:33:48,170
And we see the chain ID is 137. 
可以看到 chainId 是 137

10557
10:33:48,170 --> 10:33:54,260
So I'll do 137. What's a little brackets here, 
所以这里就是 137 然后是一组括号

10558
10:33:54,800 --> 10:33:58,700
we'll say name, polygon. Then we'll do a comma eth USD, price feed. 
还有 `name: "polygon", ethUsdPriceFeed`

10559
10:33:58,700 --> 10:34:04,130
And then we'll add the price feed of eth USD on polygon. 
接着我们要添加 Polygon "ETH/USD" 的 "priceFeed" 

10560
10:34:04,130 --> 10:34:09,200
So docstoc, chain link, polygon or Matic and then we'll look up eth, USD. 
所以来到 "docs.chain.link" -> "Polygon (Matic)" 找到 "ETH/USD"

10561
10:34:09,200 --> 10:34:12,770
And boom, we see it right here. We've grabbed this address, and we paste it in. 
可以看到就在这里，获取这个地址，并粘贴过来

10562
10:34:12,770 --> 10:34:15,620
Well, what about the Hardhead? Network? 
那么 "Hardhat Network" 是什么样的呢

10563
10:34:15,620 --> 10:34:18,620
We'll get to that in just a second, don't you worry. 
我们马上就会解释，不要着急

10564
10:34:18,620 --> 10:34:21,710
And then at the bottom, we need to export this network config. 
接着来到底部，我们需要导出这个 "networkConfig"

10565
10:34:21,710 --> 10:34:28,100
So our other scripts can actually work with it. 
以便我们的其它脚本能够使用它

10566
10:34:28,100 --> 10:34:31,070
So we'll do module dot exports equals network config. 
所以我们要写下 `module.exports = {networkConfig}`

10567
10:34:31,070 --> 10:34:34,160
And we're going to actually export a couple of things from this file, 
我们还要从这个文件中导出一些其它东西

10568
10:34:34,160 --> 10:34:37,580
which is why we're doing it like this instead of that default way that I showed you before. 
这也是为什么这里没有像之前展示的那样使用 `default` 的方式

10569
10:34:37,760 --> 10:34:41,390
So back in our script, now, what can we do? 
回到我们的脚本，现在我们能做些什么呢？

10570
10:34:41,420 --> 10:34:47,810
Well, first, we want to go ahead and import that network config. 
首先，我们要做的是导入网络配置

10571
10:34:47,810 --> 10:34:51,590
So we'll say const. Network config equals require, 
所以就是 `const {networkConfig} = require("")`

10572
10:34:51,590 --> 10:34:54,920
and then we'll import it, we'll go down and directory to help our Hardhead config and save. 
现在导入它，上一级目录的 `helper-hardhat-config`，然后保存

10573
10:34:54,920 --> 10:34:57,410
And I just want to mention this one more time, just so that it doesn't confuse anybody. 
我想要再提醒一下这个，以免让人混淆

10574
10:34:57,410 --> 10:35:00,710
This syntax here, constant network config with the little curly braces around it 
这个语法 `const {networkConfig}` 带有一组花括号

10575
10:35:00,710 --> 10:35:08,990
is the same is if I went const. Helper config equals this thing, 
它就和 `const helperConfig` 等于这些东西

10576
10:35:10,100 --> 10:35:13,280
which helper config is now kind of this whole file. 
现在 `helperConfig` 就代表了整个文件

10577
10:35:13,280 --> 10:35:21,020
And then const network config equals Hopper config dot network config. 
然后是 `const networkConfig = helperConfig.networkConfig`

10578
10:35:21,440 --> 10:35:24,890
So again, this index is just kind of an easy way 
所以，这个语法就是一个简便用法

10579
10:35:24,890 --> 10:35:28,610
to extrapolate or pull out just the network config from this file. 
它会推断并提取出 `networkConfig`，从这个文件中

10580
10:35:28,610 --> 10:35:31,850
So that's how that works. 
这就是它的工作原理

10581
10:35:31,850 --> 10:35:35,600
And that's why we export it at the bottom so that we can do this, 
这也是为什么我们要在底部导出它的原因，就是为了做这个操作

10582
10:35:35,600 --> 10:35:39,410
please use the GitHub repository to ask questions and discussions 
请尽情使用 GitHub 仓库来进行提问和讨论

10583
10:35:39,410 --> 10:35:41,840
especially about some of this JavaScript stuff. 
尤其是有关 JavaScript 的这些东西

10584
10:35:41,840 --> 10:35:44,630
Alright, great. So now that we have this network configured here, 
很好，现在我们有了这些网络配置

10585
10:35:44,630 --> 10:35:48,950
we can now do this part of where we say if China d z use a if chain ID is x use y. 
现在我们就可以进行这个操作了 “如果 chainId 是 Z 则使用 A 如果 chainId 是 X 则使用 Y”

10586
10:35:48,950 --> 10:35:52,670
So Since our helper config is nicely in this kind of dictionary, key value pair style, 
由于我们的 `helperConfig` 很好地使用了这种字典的键值对儿格式

10587
10:35:52,670 --> 10:35:58,490
what we can do is we can say const. eth USD. Price feed address equals network config at the chain ID, 
所以我们可以这么做 `const ethUsdPriceFeedAddress = networkConfig[chainId]`

10588
10:35:59,060 --> 10:36:08,360
because if Francina D, or it'll be this object, 
如果 "chainId" 是 4 那么就是这个对象

10589
10:36:08,690 --> 10:36:12,770
French entity polygon, it'll be this object 
如果 "chainId" 是 Polygon，就会是这个对象

10590
10:36:12,770 --> 10:36:21,470
at the eth USD price feed, 
`["ethUsdPriceFeed"]`

10591
10:36:21,470 --> 10:36:24,950
we're going to save this to eth USD price feed address. 
我们要把这个保存到 `ethUsdPriceFeedAddress`

10592
10:36:24,950 --> 10:36:27,980
And now no matter what chain we're on, whenever we run hard hat deploy,
现在无论我们是在哪条链上，只要我们运行 `hardhat deploy`

10593
10:36:28,130 --> 10:36:34,550
if I run yarn, hard hat deploy dash dash network Rinkeby. 
如果我运行 `yarn hardhat deploy --network rinkeby`

10594
10:36:34,550 --> 10:36:37,940
This chain ID is going to be four. 
这个 "chainId" 就会是 4

10595
10:36:37,940 --> 10:36:42,500
And so it's going to use this price feed address. 
接着它就会使用这一个喂价地址

10596
10:36:42,500 --> 10:36:45,560
If I do dash test network polygon, and I remember to add both ring P and polygon to my networks, like here, 
如果我运行 `--network polygon`，当然，要记得在把 Rinkeby 和 Polygon 都添加到 "networks" 里

10597
10:36:45,560 --> 10:36:48,770
the channel is going to be 137. It's going to use this price feed address. 
"chainId" 就会是 137 并使用这个喂价地址

10598
10:36:48,770 --> 10:36:52,310
So this is awesome. This is exactly what we want. 
真是太棒了，这正是我们想要的

10599
10:36:52,310 --> 10:36:55,340
But is it everything that we want? 
但这是我们想要的全部么？

10600
10:36:55,340 --> 10:36:58,040
Those of you who have been questioning while I have been coding and talking, 
也许会有人在我编码和讲话时产生疑问

10601
10:36:58,040 --> 10:37:00,590
you might be thinking, Okay, well, you talked about this marking thing. You talked about localhost and hard hat. 
你可能在想，OK 你提到了 mocking 还提到了本地主机和 Hardhat

10602
10:37:00,590 --> 10:37:03,500
And how do we test this locally? 
但我们该怎么在本地做测试呢？

10603
10:37:03,500 --> 10:37:06,410
Like this is how we go to a test net and a main net. 
这些都是在告诉我们怎么去测试网或者主网上

10604
10:37:06,410 --> 10:37:09,740
But what about a local network? 
但是本地网络呢？

10605
10:37:09,740 --> 10:37:13,370
And that is exactly what we're going to talk about now. 
这正是我们现在马上要讨论的东西

10606
10:37:13,370 --> 10:37:16,760
So we've modularized, our code and parameterize our code 
我们已经模块化和参数化了我们的代码

10607
10:37:16,760 --> 10:37:20,240
so that we're going to use the address based off of the chain that we're on. 
这样我们就可以基于我们所处的链来使用对应的地址了

10608
10:37:20,240 --> 10:37:24,020
But what if we use a chain that doesn't even have a price feed address on it?
但如果我们使用的链甚至都没有喂价地址呢？

10609
10:37:24,080 --> 10:37:27,470
What do we do there? This is where we actually create those mock contracts. 
那我们该怎么办？这就是我们要创建 "mock" 合约的地方了

10610
10:37:27,500 --> 10:37:32,120
The idea of mock contracts here is if the contract doesn't exist, 
"mock" 合约的想法是，如果某个合约不存在

10611
10:37:32,120 --> 10:37:37,550
we deploy a minimal version of it for our local testing, or our local testing. 
我们就部署一个最小化的版本来进行我们的本地测试

10612
10:37:37,580 --> 10:37:42,530
And deploying mocks is technically a deploy script. 
部署 "mock" 从技术上来说也是一个部署脚本

10613
10:37:42,530 --> 10:37:48,200
So what we do actually
我们实际上做的就是

10614
10:37:48,230 --> 10:37:51,080
is back in our deploy folder is we're going to create a new file, 
回到我们的 "deploy" 文件夹，创建一个新文件

10615
10:37:51,080 --> 10:37:58,340
and we're going to call it 00 Dash deploy mocks dot j s, 
我们将其命名为 "00-deploy-mocks.js"

10616
10:37:58,340 --> 10:38:01,670
we started with 00. Because this is almost like the pre deploy stuff, 
我们从 00 开始是因为这几乎就是一个预部署的东西

10617
10:38:01,670 --> 10:38:05,480
we only do this, sometimes we don't always deploy mocks, right, 
我们只是有时候这么做，并不会总是部署 "mock" 对吧？

10618
10:38:05,480 --> 10:38:08,750
we don't need to deploy mocks to Rinkeby, or polygon or or Aetherium main net, 
我们不需要把 "mock" 部署到 Rinkeby 或 Polygon 或以太坊主网

10619
10:38:08,750 --> 10:38:11,810
because those already have these price feeds, 
因为他们都已经有喂价数据了

10620
10:38:11,810 --> 10:38:15,200
we're actually going to deploy our own mock price feed contracts. 
我们要部署一个自己的 "mock" 喂价合约

10621
10:38:15,350 --> 10:38:19,700
And in our deploy Funmi script,
在我们的 "deploy-fund-me" 脚本里

10622
10:38:19,730 --> 10:38:23,780
we're going to use our own contracts, instead of already established contracts. 
我们要使用我们自己的合约，而不是已建立的合约

10623
10:38:23,780 --> 10:38:26,990
If we're on a network that doesn't have any price, few contracts, 
如果我们在一个没有任何喂价合约的网络上

10624
10:38:27,020 --> 10:38:30,770
like hard hat or locos, for example.
比如说像 Hardhat 本体主机

10625
10:38:30,860 --> 10:38:34,160
So let's write our deploy mock script. 
让我们开始编写我们的 "deploy-mocks" 脚本

10626
10:38:34,160 --> 10:38:37,430
So the setup of this is going to look nearly identical to our deploy Funmi. 
这里的配置和我们的 "deploy-fund-me" 几乎相同

10627
10:38:37,430 --> 10:38:41,270
And again, if you want to set it up like this, you absolutely can. 
当然，如果你想用这种方式进行设置，完全是可以的

10628
10:38:41,270 --> 10:38:43,880
But I'm actually just going to copy this, this part, paste it in here, 
但我会选择复制这部分，粘贴到这里

10629
10:38:43,880 --> 10:38:46,820
because that initial part is going to be exactly the same.
因为初始部分是完全相同的

10630
10:38:47,000 --> 10:38:49,340
Oh, and over here, I just realized that we're calling this network thing without being defined, 
哦，这个地方，我们正在调用这个 `network` 但没有定义

10631
10:38:49,340 --> 10:38:52,160
JavaScript will kind of be smart enough to know where this network thing is coming from. 
JavaScript 很智能，知道这个 `network` 来自哪里

10632
10:38:52,160 --> 10:38:54,770
But it can be a little bit confusing. 
但这可能会让人产生一点疑惑

10633
10:38:54,770 --> 10:38:57,860
So it's better to be really explicit, 
所以最好还是明确一点

10634
10:38:57,860 --> 10:39:03,740
and say, const. Network equals require hard hat,
写下 `const {network} = require("hardhat")`

10635
10:39:03,980 --> 10:39:07,130
this network thing is coming from hard hat. 
这个 `network` 来源于 "hardhat"

10636
10:39:07,130 --> 10:39:10,370
And we're going to grab this line. And we're also going to use this 
我们复制这一行，因为这里也要使用它

10637
10:39:10,370 --> 10:39:13,460
at the top of our script here. 
放到我们脚本的顶部

10638
10:39:13,490 --> 10:39:16,160
And then our top section is going to look exactly the same as well, 
这样顶部的部分看起来就完全一样了

10639
10:39:16,250 --> 10:39:19,490
we're going to grab these three lines, and paste them in 
我们复制这三行，然后粘贴过来

10640
10:39:19,490 --> 10:39:21,530
deploy deployer chain ID, boom, it's all going to be the same here, 
`deploy deployer chainId`，boom，这里也完全一样

10641
10:39:21,530 --> 10:39:25,100
because we're setting up to deploy some stuff. 
因为我们正在配置部署一些东西

10642
10:39:25,100 --> 10:39:28,460
Now we want to deploy a new contract. 
现在我们想要部署一个新的合约

10643
10:39:28,580 --> 10:39:32,450
But if we look at our contracts folder, this is all we have right now. 
查看一下我们的 "contracts" 文件夹，这就是目前我们所拥有的全部了

10644
10:39:32,450 --> 10:39:35,330
So we're going to need to add this mock this fake contract to our contracts folder. 
所以我们需要添加这个 "mock" 虚拟合约到我们的 "contracts" 文件夹中

10645
10:39:35,330 --> 10:39:38,810
Now what we can do is in our contracts folder, 
现在我们要在 "contracts" 文件夹中

10646
10:39:38,810 --> 10:39:41,900
we want to separate this file from the rest of our file 
将这个文件与其它文件分离开来

10647
10:39:41,900 --> 10:39:44,990
so that we know okay, this isn't part of our project, but it is part of our testing. 
这样我们就能知道，它并不是我们项目的一部分，而是用来进行测试的部分

10648
10:39:44,990 --> 10:39:49,160
So we're going to right click Create New Folder. 
所以我们要右键，点击新建文件夹("Net Folder")

10649
10:39:49,160 --> 10:39:52,220
And we can either call it mocks, or test I like to call mine test. 
我们可以将其命名为 "mocks" 或者 "test"，我喜欢用 "test"

10650
10:39:52,220 --> 10:39:54,890
And inside of this folder, we can go ahead and right click create a new file, 
在这个文件夹里，我们继续右键点击新建文件("New File")

10651
10:39:54,920 --> 10:40:01,940
I'm going to create a new file and call it mock, v3 aggregate tore that soul. 
我们将创建一个新文件并命名为 "MockV3Aggregator.sol"

10652
10:40:01,940 --> 10:40:05,360
And this is where we're going to define our mock price feed aggregator ourselves. 
这就是我们用来定义我们自己的 "mock" 喂价聚合器的地方

10653
10:40:05,390 --> 10:40:09,650
So how can we create our own fake price feed contract, 
那么我们该如何创建自己的虚拟喂价合约

10654
10:40:09,650 --> 10:40:12,620
so we can test everything locally? 
以便能够进行所有的本地测试呢？

10655
10:40:12,620 --> 10:40:16,010
Well, one thing we could do is we go to the chain link GitHub repo, 
其中一个可用的方法是，前往 Chainlink 的 GitHub 仓库

10656
10:40:16,010 --> 10:40:18,470
and go through the contracts and find one of these price feed addresses, 
并进入 "contracts" 找到一个 "priceFeedAddress"

10657
10:40:18,470 --> 10:40:22,640
source eight, or maybe we'll go back to source 
"src/v0.8"，或者我们先回到 "src"

10658
10:40:22,640 --> 10:40:24,500
we'll maybe we'll check in V six.
也许我们会选择 "v0.6"

10659
10:40:26,360 --> 10:40:29,510
Looks like we could find some stuff and look around 
看起来我们可以找到一些东西并进行查看

10660
10:40:29,510 --> 10:40:32,690
and we probably copy paste all this code, 
或许我们可以复制粘贴这里的全部代码

10661
10:40:32,690 --> 10:40:35,060
but it really seems like kind of a huge pain in the butt to have to copy all this code.
但这真的是有些麻烦，我们必须复制这里全部的代码

10662
10:40:35,210 --> 10:40:38,210
Now we absolutely could we copy paste the code in here, 
我们当然可以把所有代码都复制粘贴过来

10663
10:40:38,210 --> 10:40:40,460
but we're gonna do something a little bit more clever. 
但我们有更聪明的做法可以选择

10664
10:40:40,460 --> 10:40:44,750
So the chainlink repo actually comes with some mocks. 
Chainlink 的仓库里其实就带有一些 "mock"

10665
10:40:44,750 --> 10:40:52,040
If we go to contracts, SRC V 0.6 tests 
如果我们前往 "contracts/src/v0.6/tests/"

10666
10:40:52,040 --> 10:40:56,210
They actually have a mock v3 aggregator dot soul in here that we can use as our mock. 
他们其实有一个 "MockV3Aggregator.sol" 在这里，我们可以将其用作我们的 "mock"

10667
10:40:56,210 --> 10:40:59,690
So we can copy paste everything, 
我们可以复制粘贴所有内容

10668
10:40:59,690 --> 10:41:03,080
but we'd have to revamp a little bit of it 
但我们必须对其进行一点修改

10669
10:41:03,080 --> 10:41:06,530
because it's doing some dot dot stuff. 
因为它正在进行某些操作

10670
10:41:06,530 --> 10:41:10,010
It's talking to other contracts that are locally in this file structure 
它正在与此文件架构中的其它本地合约进行交互

10671
10:41:10,040 --> 10:41:13,340
that are not going to be in our file structure. 
而这些合约并不会出现在我们的文件结构中

10672
10:41:13,340 --> 10:41:19,130
So instead though, what we can do is we can use this node modules package to our advantage, 
我们可以利用这个 "node_modules" 包来帮我们处理

10673
10:41:19,670 --> 10:41:22,610
we can just say pragma, solidity, carrot zero, point 6.0, 
我们可以写下 `pragma solidity ^0.6.0;`

10674
10:41:22,610 --> 10:41:28,130
we'll use the same version that that package is doing. 
我们要使用和这个包相同的版本

10675
10:41:28,160 --> 10:41:35,840
And then just do import at a chain link slash contracts slash SRC slash v 0.6. Slash tests slash mock, B, three egg, Reg, gay tore that soul. 
然后是 `import @chainlink/contracts/src/v0.6/tests/MockV3Aggregator.sol`

10676
10:41:35,840 --> 10:41:40,340
And then we'll add, and then of course, we'll add spdx, license identifier, MIT. 
当然了，还需要添加 `SPDX-License-Identifier: MIT`

10677
10:41:40,340 --> 10:41:46,040
And boom, this is actually all we need. 
嘭，这就是我们所需要的全部了

10678
10:41:46,040 --> 10:41:50,930
If we just import the code like this,
如果我们只像这样导入这些代码

10679
10:41:50,960 --> 10:41:54,830
remember, this is exactly the same as copy pasting this contract into our project, 
记住，这与将此合约复制粘贴到我们的项目中完全相同

10680
10:41:54,830 --> 10:41:59,000
of course, with this path resolve to where it actually is in our node modules. 
当然，需要将其路径解析为实际在我们 "node_modules" 中的位置

10681
10:41:59,000 --> 10:42:03,140
Now, actually, I can run yarn hardhat compile, 
现在，我们就可以执行 `yarn hardhat compile`

10682
10:42:03,140 --> 10:42:07,910
and it will also compile this contract. 
它同样也会编译这个合约

10683
10:42:07,910 --> 10:42:12,350
Except for of course, we have an issue, 
当然了，我们还会遇到问题

10684
10:42:12,350 --> 10:42:15,530
hey, compiler versions don't match. Right? What's What's up with that 
嘿，编译器版本不匹配，对吧？这是怎么回事

10685
10:42:15,560 --> 10:42:18,020
now, you're going to get into situations 
现在，你将会遇到这样的情况

10686
10:42:18,020 --> 10:42:20,780
where you will be working with contracts that are not the same version of solidity as you 
你调用的合约使用与你不同版本的 Solidity 

10687
10:42:20,780 --> 10:42:23,840
why well because contracts keep being deployed all the time. 
为什么呢？因为合约在任何时候都可以部署

10688
10:42:23,870 --> 10:42:26,660
And there are a ton of contracts that are in version 0.4, solidity, 0.5 0.678, 
因此会有大量合约使用 "0.4" 版本的 Solidity，也会有 "0.5" "0.6\7\8" 

10689
10:42:26,660 --> 10:42:32,540
and probably 910, or 15 billion, or however many solidity versions will come to be. 
大概还会有 "0.9\10" 甚至是 150 亿，或是任何将要出现的 Solidity 版本

10690
10:42:32,540 --> 10:42:35,180
So in our config, in our hard hat dot config, 
所以在我们的配置文件 "hardhat.config" 中

10691
10:42:35,180 --> 10:42:38,930
when you scroll to the bottom, 
我们可以滑到底部

10692
10:42:38,930 --> 10:42:41,870
we can scroll to where we're defining our solidity version. 
滑到定义 Solidity 版本的地方

10693
10:42:41,900 --> 10:42:45,500
And we can actually add multiple solidity versions, 
其实我们可以添加多个 Solidity 版本

10694
10:42:45,500 --> 10:42:49,520
so that our compiler can compile multiple versions of solidity. 
这样我们的编译器就可以编译多个版本的 Solidity

10695
10:42:49,520 --> 10:42:54,110
To do that, we'll say, so Lyd, did T. 
为此，我们要写 `solidity`

10696
10:42:54,110 --> 10:42:57,890
And we'll turn it into an object here, 
我们要把它转换为一个对象

10697
10:42:57,890 --> 10:43:01,850
we'll make sure to put this comma here. 
不要忘了这里还有一个逗号

10698
10:43:01,850 --> 10:43:05,840
And inside our solidity object, we'll put compilers 
在我们的 `solidity` 对象内部写下 `compilers`

10699
10:43:06,260 --> 10:43:09,770
and we'll have a list of compilers. 
我们会有一个 `compilers` 的列表

10700
10:43:09,770 --> 10:43:15,080
Our first one we'll say is version, zero, point 8.8. 
第一个，我们告诉它 `version: "0.8.8"`

10701
10:43:15,680 --> 10:43:17,900
And we'll say our second one is going to be version 0.6, point six, 
然后第二个是 `version: "0.6.6"

10702
10:43:17,900 --> 10:43:21,830
and then we'll go ahead and save that. 
接着我们保存一下

10703
10:43:22,430 --> 10:43:26,360
And it looks like mine wanted to format it like this, which is fine. 
看来我的格式化方式是这样的，很不错

10704
10:43:26,360 --> 10:43:29,840
Now, we can go ahead, rerun, yarn, Hardhead, compile, 
现在我们就可以继续了，重新运行 `yarn hardhat compile`

10705
10:43:29,900 --> 10:43:34,340
and boom, compiled five solidity files successfully. 
嘭，成功编译了五个 Solidity 文件

10706
10:43:34,340 --> 10:43:38,870
This means that our Mark V aggregator should also have been compiled. 
这意味着我们的 "MockV3Aggregator" 应该也编译好了

10707
10:43:38,870 --> 10:43:41,570
And if we look in artifacts, at chain link, 
如果我们查看 "artifacts/@chainlink"

10708
10:43:41,570 --> 10:43:45,620
do indeed see this at chain link slash contract slash SRC bid, and a v 0.6. In tests, 
我们确实可以看到在 "@chainlink/contracts/src/v0.6/tests" 下

10709
10:43:45,650 --> 10:43:50,180
we see this mock aggregator dot soul, which has been compiled. 
有一个 "MockV3Aggregator.sol"，已被编译

10710
10:43:50,180 --> 10:43:53,660
Awesome. So now that we have our mock contract compiled, 
太好了，现在我们的 "mock" 合约已经编译好了

10711
10:43:53,780 --> 10:43:56,690
we now have a contract that we can use to deploy a fake price feed to a blockchain. 
现在我们拥有了一个将虚拟喂价合约部署到区块链上的合约

10712
10:43:56,690 --> 10:43:59,420
So how do we actually do this? 
现在我们该怎么做

10713
10:43:59,420 --> 10:44:04,400
Well, it's going to be the exact same way that we deployed the Funmi contract. 
其实就和我们部署 "FundMe" 合约的方法几乎完全一样

10714
10:44:04,400 --> 10:44:08,390
But we're going to add a little if statement in here, 
区别就是我们要在这里添加一个 "if" 语句

10715
10:44:08,390 --> 10:44:13,220
we don't want to deploy this mock contract to a test net or a network that actually has a price feed on it, 
我们不打算把这个 "mock" 合约部署到测试网或是已经有喂价数据的网络上

10716
10:44:13,220 --> 10:44:17,270
we could just do something like if chain ID does not equal, you know, some chain ID, then deploy marks, right. 
我们可以这么做 `if (chainId != )` 某些 "chainId" 然后就 `deploymocks`

10717
10:44:17,270 --> 10:44:19,640
And then this is kind of pseudocode. Obviously, this code won't actually work. 
当然这是一种伪代码，它们是无法实际运行的

10718
10:44:19,640 --> 10:44:22,910
But instead, what I like is I actually like to specify 
相反，我喜欢指定

10719
10:44:22,910 --> 10:44:25,550
which chains are going to be my development chains, 
哪些条链是我的开发链

10720
10:44:25,550 --> 10:44:29,600
which chains are going to be the one that I can deploy these mocks to, 
哪些链是我要部署 "mock" 的链

10721
10:44:29,600 --> 10:44:32,960
in my helper, hard hat config, I'll define these chains. 
在我的 "helper-hardhat-config" 中，我会定义这些链

10722
10:44:32,960 --> 10:44:38,630
So I'll say const, development chains, equals, 
因此我会写下 `const developmentChain = `

10723
10:44:38,630 --> 10:44:45,980
and then I'll just say hard hat, and local host. 
接着我会说有 "hardhat" 以及 "localhost"

10724
10:44:45,980 --> 10:44:51,350
I'll export these. And back in my deploy mocks, 
我会导出它们，然后回到我的 "deploy-mocks"

10725
10:44:51,380 --> 10:44:58,040
I'll import these with const. Development chains equals require dot dot slash helper Hardhead config. 
导入它们 `const {developmentChains} = require("../helper-hardhat-config")` 

10726
10:44:58,160 --> 10:45:06,170
And now I'll say if development chains dot includes chain ID. 
现在我要写下 `if (developmentChains.includes(chainId))`

10727
10:45:06,170 --> 10:45:10,040
This includes keyword basically is a function that checks to see 
这个 `includes` 关键字就是一个函数，它会检查

10728
10:45:10,190 --> 10:45:13,430
if some variable is inside an array, 
如果某些变量在某个数组中

10729
10:45:13,430 --> 10:45:17,030
then we're gonna go ahead and deploy Max, and which is what we want to do. 
我们就继续部署 "mock"，这正是我们想做的

10730
10:45:17,090 --> 10:45:19,760
So we'll do log, which we're getting from deployments, which is basically console dot log. 
执行 `log()`，这是从 "deployments" 中获取的，基本就等于 `console.log`

10731
10:45:19,760 --> 10:45:24,980
And we'll say local network detected, deploying mocks. 
我们会说 "Local network detected! Deploying mocks..." (“检测到本地网络！部署 mocks...”)

10732
10:45:25,640 --> 10:45:27,620
And we'll do a weight ploy, 
接着就是 `await deploy()`

10733
10:45:28,970 --> 10:45:34,940
and we'll deploy our new mock v3 aggregator 
部署我们的新 "MockV3Aggregator"

10734
10:45:34,940 --> 10:45:40,130
mock v3 aggregator will do a comma. There a little colons here. 
"MockV3Aggregator" 后面是逗号，然后是冒号(应为括号)

10735
10:45:40,130 --> 10:45:43,430
If we want to get really specific, 
如果我们想比较具体

10736
10:45:43,430 --> 10:45:47,630
we can say contract v3 aggregator which we're kind of already saying
就这么说 `contract: "MockV3Aggregator"` 某种程度上我们已经这么说了

10737
10:45:47,660 --> 10:45:51,680
we'll say from deployer 
然后是 `from: deployer`

10738
10:45:53,030 --> 10:45:56,390
We'll say logging is going to be true. 
`log: true`

10739
10:45:56,390 --> 10:46:00,080
And then we need to pass some arguments, 
接着我们需要传递一些参数

10740
10:46:00,170 --> 10:46:04,310
we need to pass the constructor parameters for the mock v3 aggregator, which are what? 
我们要为 "MockV3Aggregator" 的构造函数传递参数，应该是什么呢？

10741
10:46:04,340 --> 10:46:09,800
Well, let's go to docs chain to link to find out. 
让我们前往 "docs.chain.link" 寻找答案 

10742
10:46:10,010 --> 10:46:13,790
Or you can also just go to Node modules chainlink, SRC V 06, tests, 
或者你可以转到 "node_modules/@chainlink/src/v0.6/tests" 

10743
10:46:13,790 --> 10:46:17,270
and then all the way down to mock V three, aggregated out. So 
然后找到 "MockV3Aggregator.sol"

10744
10:46:17,270 --> 10:46:19,640
where you could also find the constructor in here, 
你也可以在这里找到构造函数

10745
10:46:19,640 --> 10:46:24,680
whatever one you like better, sometimes I find it easier just to read GitHub 
你喜欢哪一个用哪一个就好，有时候我觉得去 GitHub 找更容易一些

10746
10:46:25,160 --> 10:46:29,570
Ctrl plus F or Command plus F for constructor. 
"Ctrl + F" 或者 "Command + F" 搜索 "constructor"

10747
10:46:29,570 --> 10:46:33,050
We see it takes a decimals and an initial answer. 
我们看到，它需要一个 "_decimals" 和一个 "_initialAnswer"

10748
10:46:33,050 --> 10:46:36,380
And if we read through the code, 
如果我们通读代码

10749
10:46:36,380 --> 10:46:40,700
we'll learn that the decimals object is going to be equivalent to 
就会了解到 "_decimals" 对象就等同于

10750
10:46:40,970 --> 10:46:43,190
the decimals parameter is going to be equivalent to this decimals function 
"_decimals" 参数就等同于这个 "decimals" 函数

10751
10:46:43,190 --> 10:46:45,680
and the initial answer. And the initial answer is basically just going to be what is the price feed starting at, 
而这个 "_initialAnswer" 基本上就是喂价是多少的意思

10752
10:46:45,680 --> 10:46:48,710
we actually get to pick the price of the price feed, 
我们可以指定喂价的价格

10753
10:46:48,710 --> 10:46:51,170
which works out really well, because that works out great for testing. 
这一点非常好，因为这样很好测试

10754
10:46:51,170 --> 10:46:53,780
I usually like to define the decimals and the initial answers somewhere outside of this function 
我通常喜欢把 "_decimals" 和 "_initialAnswer" 的定义放到函数之外

10755
10:46:53,780 --> 10:46:57,050
so that I can access it later. 
这样我以后就能随时访问它们了

10756
10:46:57,050 --> 10:47:00,410
One good place you can add it is once again in our helper Hardhead config.js. 
一个添加它们的好地方是，又一次是我们的 "helper-hardhat-config.js"

10757
10:47:00,410 --> 10:47:06,740
So I might do const decimals equals eight. 
我可能会写 `const DECIMALS = 8`

10758
10:47:06,740 --> 10:47:15,740
And then const initial answer. Answer equals, and we'll do 2000. 
然后是 `const INITIAL_ANSWER = 2000`

10759
10:47:15,770 --> 10:47:20,930
So since we have a decimals, we'll do 2000 
既然我们的 "DECIMALS" 是 8 这里我们就取 2000

10760
10:47:20,930 --> 10:47:24,650
And then 123456788 decimal places, 
后面是 12345678，8 个小数位

10761
10:47:24,650 --> 10:47:28,760
and then we'll export these as well. Export decimals, and export initial answer. 
然后我们同样把它们导出出来，导出 `DECIMALS` 以及 `INITIAL_ANSWER`

10762
10:47:28,760 --> 10:47:32,480
We could of course, just do you know, const decimals equals eight at the top 
当然了，我们也可以把 `const DECIMALS = 8` 放到顶部

10763
10:47:32,480 --> 10:47:35,540
and then initial answer and then use them down here. 
然后下面是 `INITIAL_ANSWER` 

10764
10:47:35,540 --> 10:47:38,660
But I like to do it like that. 
但我更喜欢刚才那样做

10765
10:47:39,260 --> 10:47:43,640
So Conce. So now we have to import them in here. 


10766
10:47:43,640 --> 10:47:47,120
const development chains. It's also grabbed decimals. 


10767
10:47:47,120 --> 10:47:49,550
It's also grabbed initial answer, we'll save it. 


10768
10:47:49,550 --> 10:47:52,820
We'll take a look back at the constructor looks like it's decimals first, initial answers second. 


10769
10:47:52,820 --> 10:47:57,440
So in our arguments, we'll do decimals first, initial answers second, 


10770
10:47:57,440 --> 10:48:01,940
and tada. And then we will be all done 


10771
10:48:01,940 --> 10:48:05,450
that we'll do a quick log box deployed. 


10772
10:48:05,450 --> 10:48:08,030
And then I also like to do kind of like a big line at the end of all of my deploy scripts 


10773
10:48:08,030 --> 10:48:11,180
just to be like, hey, that's the end of this deploy script. 


10774
10:48:11,180 --> 10:48:14,390
Anything else after this is going to be a different deploy script. 


10775
10:48:14,390 --> 10:48:17,600
All right, great. Now our deployed mocks script is actually done. 


10776
10:48:17,840 --> 10:48:21,770
But our deploy Funmi script isn't quite done. 


10777
10:48:21,770 --> 10:48:25,190
Is there a way that we could run only our deploy mock script? 


10778
10:48:25,190 --> 10:48:27,890
Well, yes, there is. Great, thanks for asking. 


10779
10:48:27,920 --> 10:48:35,000
What we can do at the bottom of our deploy mock script 


10780
10:48:35,000 --> 10:48:40,430
is we can add a module that exports dot tags, equals, and we'll say all and marks. 


10781
10:48:40,430 --> 10:48:45,770
Now what we can do is if we run yarn, hard hat deploy, we can add this flag dash dash tags.


10782
10:48:46,190 --> 10:48:50,540
And it will only run the deploy scripts that have a special tag.


10783
10:48:50,930 --> 10:48:55,310
So we'll run our mocks tag, which means it'll only run our deploy mock script. 


10784
10:48:55,310 --> 10:48:59,840
And, and oops, actually, in our helper config 


10785
10:48:59,840 --> 10:49:03,440
development chains is actually hard hat and localhost.


10786
10:49:03,440 --> 10:49:06,860
And I said, we're going to try to do with the chain ID, 


10787
10:49:06,890 --> 10:49:09,380
sorry, we're going to do this, 


10788
10:49:09,380 --> 10:49:11,990
we're gonna do development chains dot includes network dot name.


10789
10:49:15,350 --> 10:49:19,880
Because our helper config is using names and not chain IDs,


10790
10:49:19,910 --> 10:49:23,030
so if development chains that includes that network the names,


10791
10:49:23,060 --> 10:49:25,670
then we're gonna go ahead and deploy the mocks. 


10792
10:49:25,670 --> 10:49:28,730
So let's go ahead and run this yarn here and hit Deploy dash dash tags, mocks. 


10793
10:49:28,730 --> 10:49:32,990
And perfect we do indeed see our mocks getting deployed here. 


10794
10:49:32,990 --> 10:49:36,620
This log true means that it's going to spit out stuff like this. 


10795
10:49:36,620 --> 10:49:39,560
It'll say contract, it's deploying, it'll say the transaction it's doing 


10796
10:49:39,560 --> 10:49:42,830
and it'll say where it was deployed with how much gas 


10797
10:49:42,830 --> 10:49:47,000
and awesome This means our deployed Mach script is working perfectly. 


10798
10:49:47,000 --> 10:49:50,570
So now we have our deploy mocks script working perfectly. 


10799
10:49:50,600 --> 10:49:54,170
So how do we apply that back to our deploy Funmi script? 


10800
10:49:54,200 --> 10:49:57,440
Well, we're gonna do the exact same thing here.


10801
10:49:57,980 --> 10:50:01,070
Instead of making eth USD price feed address constant variable,


10802
10:50:01,100 --> 10:50:04,700
we're gonna say let at USD price you'd variable 


10803
10:50:04,700 --> 10:50:09,800
so that we can actually update it. 


10804
10:50:09,800 --> 10:50:15,650
And we'll say, if development chains dot includes network dot name, 


10805
10:50:15,680 --> 10:50:19,010
what we can do with hard hat deploy 


10806
10:50:19,010 --> 10:50:23,840
is we can just get the most recent deployment using a command called literally get. 


10807
10:50:23,840 --> 10:50:30,200
So we'll say const. eth USD aggregator equals await deployments dot get. 


10808
10:50:30,200 --> 10:50:34,280
And then the name of the contract that we deployed Mach v3 aggregator, 


10809
10:50:34,280 --> 10:50:37,040
and if you wanted to just do get instead of deployments dot get,


10810
10:50:37,220 --> 10:50:42,020
we absolutely could, just by doing it like this. 


10811
10:50:42,020 --> 10:50:45,080
Those are exactly the same. 


10812
10:50:45,080 --> 10:50:52,400
So we'll get the address like this and then we'll say 


10813
10:50:52,400 --> 10:50:56,900
eth USD price feed address equals that eth USD aggregator contract dot address. 


10814
10:50:56,900 --> 10:51:00,380
And then if we're not on a development chain, 


10815
10:51:00,380 --> 10:51:04,160
if we didn't deploy a mock, we're just going to do exactly what we did before. 


10816
10:51:04,160 --> 10:51:09,740
With using the network config. 


10817
10:51:09,740 --> 10:51:13,070
Oh, my goodness. Now, now that we've done all of these steps, 


10818
10:51:13,070 --> 10:51:18,260
let's add a little log thing at the bottom here with just a bunch of hyphens. 


10819
10:51:18,440 --> 10:51:22,340
Now, we should have a very robust script 


10820
10:51:22,340 --> 10:51:25,820
to flip between a local development chain, a test net chain, a main net chain, 


10821
10:51:25,820 --> 10:51:29,330
and allow us to deploy literally everywhere without changing any of our solidity. 


10822
10:51:29,330 --> 10:51:33,770
And then we just take this, this eth USD price feed address and stick it into logs here. 


10823
10:51:34,460 --> 10:51:38,450
And then at the bottom, we can do module dot exports, dot tags equals 


10824
10:51:38,450 --> 10:51:43,490
and then we'll just do all 


10825
10:51:43,490 --> 10:51:48,650
and then we'll call this one Funmi. 


10826
10:51:48,650 --> 10:51:52,430
Oh, now moment of truth. If we did all this, right, 


10827
10:51:52,430 --> 10:51:57,110
we should just be able to run yarn, hard hat deploy. 


10828
10:51:57,110 --> 10:52:00,500
And it should work on our local chain, our hard hat chain. 


10829
10:52:00,500 --> 10:52:03,950
And then it should also work on any test net that we give it. 


10830
10:52:04,340 --> 10:52:07,460
So let's give this a try. Yarn, Hardhead deploy. Let's see if this works. 


10831
10:52:07,460 --> 10:52:11,780
Awesome. And we got this all to deploy locally to our Hard Hat Network, 


10832
10:52:11,780 --> 10:52:14,780
we can see that we went ahead and we deployed mocks, we did our little underline here.


10833
10:52:15,170 --> 10:52:18,020
And then we deployed Funmi deployed at this address with this much gas. 


10834
10:52:18,050 --> 10:52:21,560
Now, what are the other awesome things about hard hat deploy? 


10835
10:52:21,560 --> 10:52:24,680
When we run our local blockchain, our own blockchain node, 


10836
10:52:24,680 --> 10:52:28,880
hard hat deploy will automatically run through


10837
10:52:29,060 --> 10:52:33,290
all of our deploy scripts and add them to our node. 


10838
10:52:33,290 --> 10:52:38,420
So now if I run yarn, hard hat node, 


10839
10:52:38,420 --> 10:52:41,690
we're going to spin up a new blockchain node, 


10840
10:52:41,690 --> 10:52:45,140
but it's already going to have all of our deployed contracts on it. 


10841
10:52:45,140 --> 10:52:48,530
So every time we spin up a local node, now 


10842
10:52:48,530 --> 10:52:54,500
it's going to come automatically packed with the contracts that we want on it. 