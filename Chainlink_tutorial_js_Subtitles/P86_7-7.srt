10343
10:21:03,320 --> 10:21:09,920
Now, how do we actually deploy this fund me contract? 
现在，我们该如何部署这个 "FundMe" 合约呢？

10344
10:21:09,920 --> 10:21:12,590
Well, let's think about this for a little bit.
让我们来仔细考虑一下这个问题

10345
10:21:12,830 --> 10:21:15,260
When working with remix, it was pretty easy, right? 
当我们使用 Remix 的时候，这是件很简单的事，对吧？

10346
10:21:15,260 --> 10:21:18,830
We just deployed it to a test net. 
我们只要直接把它部署到测试网络上就行了

10347
10:21:18,830 --> 10:21:21,590
Ah, that's kind of the issue there, isn't it 
啊，但这就是问题所在不是么？

10348
10:21:21,590 --> 10:21:24,680
deploying to a rink, the test net is a little bit slow. 
部署到 Rinkeby 测试网上实在是有点慢

10349
10:21:24,680 --> 10:21:27,920
We don't always want to have to deploy to one of these slow test nets or even a main net 
我们不想总是在这些慢速的测试网或主网上进行部署

10350
10:21:27,920 --> 10:21:31,010
when tinkering and fiddling with our contracts, do we 
从而调试和修改我们的合约，是吧？

10351
10:21:31,010 --> 10:21:34,700
know that's gonna be really bad, 
是的，那真的很糟糕

10352
10:21:34,700 --> 10:21:37,580
we really want to deploy to a test net as a last stop after we've done all our testing locally. 
我们想要的是将部署测试网这一步作为本地测试之后的最后一步

10353
10:21:37,580 --> 10:21:41,450
Or we can deploy it to a test that to see some very specific code work, 
或者我们可以提前将其部署到测试网络以查看某些特定代码如何工作

10354
10:21:41,450 --> 10:21:44,870
like for example, with the chain link documentation. 
例如与 Chainlink 文档一起使用

10355
10:21:44,870 --> 10:21:48,020
So ideally, we deploy this to a local network first. But can we just do that? 
理想情况下，我们应当首先部署到本地网络上，但我们真的可以直接这样做么？

10356
10:21:48,020 --> 10:21:51,260
Well, if we look in our price converter, dot Seoul, 
如果查看一下我们的 "PriceConverter.sol"

10357
10:21:51,260 --> 10:21:55,220
we have this hard coded address in here, this 0x address, 
我们会发现这里有一处硬编码地址，就是这个 0x 地址

10358
10:21:55,220 --> 10:21:59,570
if we go to Doc's dot chain that link EVM chains, contract addresses for Aetherium data feeds. 
如果我们前往 "docs.chain.link"-"EVM Chains"-"Contract Address"-"Ethereum Data Feeds"

10359
10:21:59,570 --> 10:22:03,560
That address is the eth USD, specifically for Rinkeby. 
那个地址是 "ETH USD" 的地址，具体来说是 Rinkeby 的

10360
10:22:03,560 --> 10:22:07,400
What if we work on the Hard Hat Network? 
如果我们想在 "Hardhat Network" 上运行呢

10361
10:22:07,580 --> 10:22:08,630
Example? default network? Hard Hat. 
比如说 `defaultNetwork: "Hardhat"`

10362
10:22:10,010 --> 10:22:13,250
And then like I said before, 
就像我之前说的

10363
10:22:13,250 --> 10:22:16,640
if you don't write this in part, it is automatically the default network. 
如果你这里不明确指定，那么 "hardhat" 将自动作为默认网络使用

10364
10:22:16,640 --> 10:22:19,430
But if we're to point to the Hard Hat Network, 
但如果我们就要指向 "Hardhat Network"

10365
10:22:19,430 --> 10:22:21,860
harder network is a blank blockchain. 
"Hardhat Network" 是一个空白的区块链

10366
10:22:21,860 --> 10:22:24,950
And it gets destroyed every time our scripts finish, 
每次我们的脚本运行完毕后它都会被销毁

10367
10:22:24,950 --> 10:22:28,220
or even if we're working with a local node, 
又或者即使我们在本地节点上工作

10368
10:22:28,220 --> 10:22:31,880
this price feed contract won't exist, 
这个 "priceFeed" 合约将不再存在

10369
10:22:31,880 --> 10:22:34,550
one of the code there won't be updated with data. So what do we do? 
其中某些代码将无法更新数据，那么我们该怎么办？

10370
10:22:34,550 --> 10:22:36,770
How do we test and interact with our code locally? Is there a way we can do this? 
我们该如何在本地测试中与我们的代码进行交互？有没有什么方式可以做到这一点？

10371
10:22:36,770 --> 10:22:39,920
Well, one of the ways that we can do this that we'll learn a little bit later 
嗯，之后我们会学习一种方法

10372
10:22:39,920 --> 10:22:42,920
is actually forking a blockchain, where you can keep stuff hard coded. 
就是所谓的分叉(fork)一个区块链，你可以在其中保留硬编码内容

10373
10:22:42,920 --> 10:22:46,370
But usually, it's still better to figure out how to do everything with something called mocks. 
但通常来说，最好的方法还是使用一种被称为 "mocks" 的方法来完成所有的操作

10374
10:22:46,370 --> 10:22:49,460
There's a great Stack Overflow question that just says, What is mocking
这里有一个很好的 "Stack Overflow" 问题问的就是，什么是 Mocking？

10375
10:22:49,520 --> 10:22:52,550
and mocking is primarily used for unit testing, which we'll talk about in a little bit. 
mocking 主要用于单元测试，我们稍后会详细讨论

10376
10:22:52,550 --> 10:22:55,880
And object under test may have dependencies on other complex objects. 
受测对象可能依赖于其它复杂的对象

10377
10:22:55,880 --> 10:22:59,480
To isolate the behavior of the object, 
为了隔离某些对象的行为

10378
10:22:59,480 --> 10:23:03,860
you want to replace other objects by mocks that simulate the behavior of the real objects. 
你需要使用 mocks 对象来替换其它对象，以模拟真实对象的行为

10379
10:23:03,890 --> 10:23:07,490
In short, mocking is creating objects that simulate behavior of real objects. 
简而言之，mocking 就是创建一个模拟真实对象行为的对象

10380
10:23:07,490 --> 10:23:10,490
Now, this might seem like a lot of words. 
看起来它说了很多东西

10381
10:23:10,520 --> 10:23:13,670
But basically, what we want to do is we want to make a fake price feed contract 
但基本来说，我们想要的就是一个虚拟的 "priceFeed" 合约

10382
10:23:14,090 --> 10:23:17,060
that we can use and we can control when working locally. 
以供我们在本地工作时能够使用并进行控制

10383
10:23:17,060 --> 10:23:20,330
So back here, I'm just going to leave a note in here saying, 
所以在这里，我会留下一条注释说

10384
10:23:20,360 --> 10:23:23,270
When going for local host or Hard Hat Network, we want to use a mock. 
当使用本地主机或 "Hardhat Network" 时，我们要使用 mock

10385
10:23:23,270 --> 10:23:30,350
Okay, great, well, we can use a mock 
OK 好，现在我们要使用 mock 了

10386
10:23:30,560 --> 10:23:33,800
and we'll learn how to make one of those in a little bit. 
之后我们将学习如何来创建一个 mock

10387
10:23:33,800 --> 10:23:36,110
Well, what happens when we want to change chains, 
但是当我们想切换链的时候会发生什么呢

10388
10:23:36,110 --> 10:23:42,290
for example, back in dots dot chain to link EVM chains, contract addresses, 
举个例子，回到 "docs.chain.link"-"EVM Chains"-"Contract Address"

10389
10:23:42,290 --> 10:23:46,490
there are a ton of different block chains that have price feeds on them. 
这里有很多不同的区块链都有价格数据源

10390
10:23:46,940 --> 10:23:50,150
And on each one of these blockchains, 
并且在这些区块链的每一个上面

10391
10:23:50,150 --> 10:23:53,840
the eth USD price feed is going to be a little bit different. 
"ETH/USD" 的价格数据可能会有一点不同

10392
10:23:53,840 --> 10:23:56,060
For example, we're looking at ETH USD, 
比方说，如果你查看 "ETH/USD"

10393
10:23:56,060 --> 10:23:59,900
the address of eth USD for Aetherium main net 
以太坊主网的 "ETH/USD" 地址

10394
10:23:59,900 --> 10:24:03,740
is different from the address of eth USD for Rigby, 
与 Rinkeby 的 "ETH/USD" 地址是不同的

10395
10:24:03,740 --> 10:24:05,840
which makes sense, they're totally different contracts on different chains, 
这是有道理的，它们是不同链上完全不同的合约

10396
10:24:05,840 --> 10:24:08,150
they have very similar functionality. And they do nearly the exact same thing. 
它们有非常相似的功能，做的也几乎是完全相同的事

10397
10:24:08,150 --> 10:24:10,970
But they're still different. 
但它们仍然是不同的

10398
10:24:11,000 --> 10:24:13,580
We're also going to need a way for us to modularize or parameterize, this address in here, 
我们还需要一种方法来把这里的地址给模块化或参数化

10399
10:24:13,580 --> 10:24:18,230
so that no matter what chain we deploy to, 
这样无论我们部署到哪个链上

10400
10:24:18,230 --> 10:24:21,410
we don't have to change any of our code, 
我们都不需要改动任何代码

10401
10:24:21,410 --> 10:24:23,810
we can always have our code be exactly the same. 
这样我们的代码可以始终保持一致

10402
10:24:23,810 --> 10:24:26,180
And we don't have to come in here and like flip values and flip variables and stuff. So 


10403
10:24:26,180 --> 10:24:29,720
let's keep that all of that in mind as we write the rest of this. 


10404
10:24:29,720 --> 10:24:32,990
Now in order to parameterize. This,


10405
10:24:33,170 --> 10:24:36,500
we actually want to prioritize and do a little refactoring of our fundamental soul. 


10406
10:24:36,500 --> 10:24:39,440
Refactoring basically means going back and, 


10407
10:24:39,440 --> 10:24:43,370
and changing the way your code works. 


10408
10:24:43,400 --> 10:24:46,340
Right now we have this constructor function, right 


10409
10:24:46,340 --> 10:24:49,190
the constructor function is the function that automatically gets called whenever we deploy our contract. 


10410
10:24:49,220 --> 10:24:52,280
Right now it's not doing a whole lot 


10411
10:24:52,280 --> 10:24:55,040
right now it's just updating the owner variable to be whoever sent in the contract. 


10412
10:24:55,040 --> 10:24:58,970
But we can actually have a do much more than that. 


10413
10:24:58,970 --> 10:25:02,030
Since this constructor is a function just like every other function, 


10414
10:25:02,030 --> 10:25:04,520
we can actually have it take parameters, 


10415
10:25:04,520 --> 10:25:07,250
one of the parameters that we might like for it to have is going to be the address of a price feed. 


10416
10:25:07,250 --> 10:25:11,270
So let's go ahead and add this and figure out how to refactor all this code. 


10417
10:25:11,270 --> 10:25:13,220
So we're going to add constructor address, 


10418
10:25:13,220 --> 10:25:17,900
price feed for the constructor in here. 


10419
10:25:18,380 --> 10:25:21,500
When we deploy our contract. Now


10420
10:25:21,530 --> 10:25:24,890
we're going to pass it the eth USD price feed address depending on what chain we're on. 


10421
10:25:24,890 --> 10:25:27,500
If we're on rink B, we'll use this address 


10422
10:25:27,500 --> 10:25:30,470
if one polygon will use a different one b&b, different one, Gnosis hecho, avalanche, etc, you get the picture. 


10423
10:25:30,470 --> 10:25:34,100
So we're going to marginalize this like so. 


10424
10:25:34,100 --> 10:25:37,730
Now that our constructor takes a parameter for the price feed, 


10425
10:25:37,730 --> 10:25:40,700
we can actually save an aggregator v3 interface object as a global variable 


10426
10:25:40,700 --> 10:25:44,420
in our price converter, 


10427
10:25:44,420 --> 10:25:47,540
we just create a price feed variable of type aggregator v3 interface, 


10428
10:25:47,540 --> 10:25:51,290
which again, we're importing from the chainlink repo, 


10429
10:25:51,290 --> 10:25:54,020
which is an interface object which gets compiled down to the ABI. 


10430
10:25:54,020 --> 10:25:57,590
If you match an ABI with up with an address, you get a contract that you can interact with. 


10431
10:25:57,590 --> 10:26:00,590
So we're going to do the same thing here. 


10432
10:26:00,590 --> 10:26:02,690
We're gonna say, aggregate Tor, v3 interface, public price feed,


10433
10:26:02,690 --> 10:26:09,530
ration and call this price feed address 


10434
10:26:10,670 --> 10:26:13,940
so that these don't have the same name. 


10435
10:26:13,940 --> 10:26:17,690
And in our constructor, we're going to say price feed equals, 


10436
10:26:17,690 --> 10:26:21,440
and we're going to do the exact same thing we did with our price converter 


10437
10:26:21,470 --> 10:26:26,360
equals aggregate tore the three interface of price feed address. 


10438
10:26:26,360 --> 10:26:27,440
Like so 


10439
10:26:28,580 --> 10:26:36,680
now, we have this price feed address 


10440
10:26:36,680 --> 10:26:40,520
that's variable and modularized, depending on whatever chain that we're on. 


10441
10:26:40,520 --> 10:26:44,030
Now, what we can do is we can grab this price feed address, 


10442
10:26:44,030 --> 10:26:47,720
and we can use it for our price converter. 


10443
10:26:47,720 --> 10:26:51,170
So where are we using our price converter? 


10444
10:26:51,170 --> 10:26:55,550
Well, just a quick reminder, we're using using price converter for you at 256. 


10445
10:26:55,550 --> 10:26:59,690
We're using this as a library on top of our unit 256 type. 


10446
10:26:59,720 --> 10:27:03,200
So we're calling message dot value dot get conversion rate. 


10447
10:27:03,200 --> 10:27:06,200
So we look at our price converter, we have this function get conversion rate, 


10448
10:27:06,200 --> 10:27:09,860
which takes an FML as its initial parameter,


10449
10:27:09,860 --> 10:27:13,490
which again, since this is a library, 


10450
10:27:13,490 --> 10:27:16,550
it automatically passes the message dot value into this get conversion rate function.


10451
10:27:17,150 --> 10:27:22,280
But we could also pass in this price feed, 


10452
10:27:22,280 --> 10:27:25,640
and therefore we wouldn't need to hard code it in the get price anymore. 


10453
10:27:25,640 --> 10:27:28,310
So let's go ahead and figure out how to do that. 


10454
10:27:28,310 --> 10:27:31,430
Well, what we can do is we can do message dot value dot get conversion rate, 


10455
10:27:31,430 --> 10:27:34,520
we'll stick price feed in here. 


10456
10:27:34,520 --> 10:27:38,240
And then we'll have to update our get conversion rate 


10457
10:27:38,240 --> 10:27:41,960
to do a comma so that it takes a second parameter, 


10458
10:27:41,960 --> 10:27:44,540
because remember, again, the initial parameter is going to be message dot value. 


10459
10:27:44,540 --> 10:27:50,210
And the second parameter is going to be what we define here. 


10460
10:27:50,210 --> 10:27:58,610
So we'll do s amount, comma ag reg gate Tor v3 interface. 


10461
10:27:58,610 --> 10:28:03,680
And we'll call this price feed. 


10462
10:28:03,680 --> 10:28:07,430
And now, when we call our get price function, 


10463
10:28:07,430 --> 10:28:14,420
we can pass the price feed to the get price function. 


10464
10:28:15,410 --> 10:28:22,220
And up here we can have get price. 


10465
10:28:22,220 --> 10:28:25,430
Take, you guessed it an aggregate or the three interface called price feed. 


10466
10:28:25,430 --> 10:28:30,020
And now we no longer need to hard code in the price feed. 


10467
10:28:30,170 --> 10:28:33,590
And we can just delete those lines and have it compile like this, which is awesome. 


10468
10:28:33,590 --> 10:28:37,250
So quick refresher, we're parameterizing that price feed address 


10469
10:28:37,250 --> 10:28:41,570
and passing it in with a constructor that gets saved as a global variable to an aggregator v3 interface type, 


10470
10:28:41,570 --> 10:28:45,770
or passing it to a get conversion rate function, 


10471
10:28:45,770 --> 10:28:48,680
which passes it to the get price function, which then just calls latest round data. 


10472
10:28:48,680 --> 10:28:50,720
And we probably could have made this even easier, probably could have just got rid of the get price function 


10473
10:28:50,720 --> 10:28:54,080
and stuck this code in the get conversion rate. 


10474
10:28:54,080 --> 10:28:56,630
But we'll leave it there for now. 


10475
10:28:56,660 --> 10:28:59,630
Now that we've done that refactoring, let's make sure it works. 


10476
10:28:59,630 --> 10:29:03,140
Yarn Hardhead, compile, invalid value undefined for hardhat dot config dot networks. 


10477
10:29:03,140 --> 10:29:07,010
Let's go to the let's go to the config real quick.


10478
10:29:07,100 --> 10:29:09,860
That's because the default network needs to be outside of networks. 


10479
10:29:09,860 --> 10:29:14,300
My mistake. Let's try that again. I spelled interface wrong and the price converter. 


10480
10:29:14,300 --> 10:29:17,360
And a quick note, if gives you an error like this, 


10481
10:29:17,360 --> 10:29:20,750
oftentimes, you can command click or control click and open that file up right in the editor, 


10482
10:29:20,750 --> 10:29:23,930
which saves you some time, we're going to have defined the line and find the file. 


10483
10:29:23,930 --> 10:29:26,240
But yeah, let's spell that correctly. 


10484
10:29:26,240 --> 10:29:29,540
And let's try this again. 


10485
10:29:29,540 --> 10:29:33,620
And awesome. It looks like it's compiling correctly. 


10486
10:29:33,620 --> 10:29:36,560
And we just have some warnings, 


10487
10:29:36,560 --> 10:29:39,560
it looks like these warnings are just about this git version, 


10488
10:29:39,560 --> 10:29:42,650
which is because we're shadowing this, we're creating a new price variable down here,


10489
10:29:42,920 --> 10:29:45,590
you've no we just created a global price free variable.


10490
10:29:46,100 --> 10:29:48,200
Let's just go ahead and delete the get version function altogether 


10491
10:29:48,200 --> 10:29:51,140
since we're not even going to really need it. 


10492
10:29:51,140 --> 10:29:53,690
And we only use the Git version to show you how to actually start working with interfaces. 


10493
10:29:53,690 --> 10:29:56,480
And then we'll compile it one more time for good measure. 


10494
10:29:56,480 --> 10:30:01,100
Boom compiled successfully. Awesome.


10495
10:30:01,130 --> 10:30:04,970
So now we've just refactored our code. 


10496
10:30:04,970 --> 10:30:08,990
So we can pass a price feed address depending on the network that we're on. 


10497
10:30:08,990 --> 10:30:12,320
Okay, great. With all that being said, let's come back to our deploy Funmi script, 


10498
10:30:12,320 --> 10:30:15,110
and let's learn how to actually deploy the rest of it. 


10499
10:30:15,110 --> 10:30:18,350
In order for us to deploy a contract 


10500
10:30:18,350 --> 10:30:22,100
we remember from our last sections that we use the contract factories, 


10501
10:30:22,100 --> 10:30:25,640
with heart hit Deploy, we can just use this deploy function. 


10502
10:30:25,640 --> 10:30:28,700
And to use the deploy function, 


10503
10:30:28,700 --> 10:30:32,300
we'll say const Funmi, which is going to be the name of our contract,  equals await. 


10504
10:30:32,300 --> 10:30:36,200
And we'll call this deploy function, the name of the contract that we're deploying right now, 


10505
10:30:36,200 --> 10:30:39,710
and then a list of overrides that we want to add here. 


10506
10:30:39,710 --> 10:30:42,650
So we're gonna say who is actually deploying this by saying from, 


10507
10:30:42,650 --> 10:30:45,980
we're gonna say it's from the Deployer. 


10508
10:30:45,980 --> 10:30:49,880
We're gonna pass any arguments to the constructor In this args piece here, 


10509
10:30:49,880 --> 10:30:55,250
which we just added a single Argh. 


10510
10:30:55,250 --> 10:30:57,530



10511
10:30:57,530 --> 10:30:59,660
So these brackets, we're going to make it a list of arguments, we're going to put the price feed address in here, which we'll show you how to do


10512
10:30:59,660 --> 10:31:03,980
in a second, put price feed address. And then we're also


10513
10:31:03,980 --> 10:31:06,260
going to do some custom logging here so that we don't have to do


10514
10:31:06,260 --> 10:31:08,600
all that console dot log stuff that we've been doing this whole


10515
10:31:08,600 --> 10:31:12,080
time. And we need to put something in here. We need to


10516
10:31:12,080 --> 10:31:15,290
put an address in here. And you can use this backslash star to


10517
10:31:15,290 --> 10:31:17,600
put like a common in between your code.


10518
10:31:18,950 --> 10:31:22,130
We can't just do const address equals, you know the address and


10519
10:31:22,190 --> 10:31:24,740
stick it in here. Well, I mean, we could but we're not really


10520
10:31:24,740 --> 10:31:27,620
prioritizing now. Right? We're kind of back to just hard coding


10521
10:31:27,620 --> 10:31:30,860
it here. So what can we do instead? Well, what we can do is


10522
10:31:30,860 --> 10:31:35,990
we can actually use the chain ID to do something like if chain ID


10523
10:31:35,990 --> 10:31:45,500
is x, use address, Y, or if chain ID is Z use address A. So


10524
10:31:45,500 --> 10:31:48,140
we can do something that looks like this. And to enable this


10525
10:31:48,140 --> 10:31:51,860
functionality, we actually take a page out of the Ave GitHub. So


10526
10:31:51,890 --> 10:31:54,830
Ave is another protocol that's on multiple chains and has to


10527
10:31:54,830 --> 10:31:57,590
deploy their code to multiple chains and work with multiple


10528
10:31:57,590 --> 10:32:01,220
different addresses. So what they do is they use a number of


10529
10:32:01,220 --> 10:32:04,070
different useful tricks. But one of the main ones is using this


10530
10:32:04,070 --> 10:32:07,340
helper hardhat config. Now they're using TypeScript with


10531
10:32:07,340 --> 10:32:10,280
JavaScript, but it's gonna be the same thing. With this


10532
10:32:10,280 --> 10:32:14,630
config, they have different variables, depending on what


10533
10:32:14,630 --> 10:32:17,690
network that they're actually on. And depending on the network


10534
10:32:17,690 --> 10:32:20,270
that they're on, they use different variables. So they use


10535
10:32:20,270 --> 10:32:24,020
this network config almost to do exactly what we're trying to do


10536
10:32:24,020 --> 10:32:27,710
here. So what we want to do is we're going to create a new file


10537
10:32:28,250 --> 10:32:32,900
at the root directory, so just click down here, new file. And


10538
10:32:32,900 --> 10:32:39,170
we're going to call it helper, hard hat config dot j, s. And


10539
10:32:39,170 --> 10:32:41,840
this is where we're going to define that network config. And


10540
10:32:41,840 --> 10:32:43,940
this is where we're going to say, hey, if you're on network,


10541
10:32:43,970 --> 10:32:48,050
a, use this address network, be this use this address, etc. So


10542
10:32:48,080 --> 10:32:52,280
we're going to create an object called const. Network config.


10543
10:32:53,000 --> 10:32:55,730
equals and we're going to add a bunch of stuff in here. So our


10544
10:32:55,730 --> 10:32:58,700
main network that we're working with right now is rinky. dinky


10545
10:32:58,700 --> 10:33:04,250
has a chain ID of four. So we'll say chain ID four is going to be


10546
10:33:04,310 --> 10:33:12,410
named Rinkeby. And the eth USD price feed address is going to


10547
10:33:12,410 --> 10:33:16,370
be the price feed address of rank B of the eth USD price


10548
10:33:16,370 --> 10:33:19,190
feed. So we're going to copied from the documentation or from


10549
10:33:19,190 --> 10:33:22,820
the GitHub, whatever you want to do, and paste it in here. Now we


10550
10:33:22,820 --> 10:33:26,000
have a simple methodology of keeping track of different price


10551
10:33:26,000 --> 10:33:29,270
feeds a different contract addresses across different


10552
10:33:29,270 --> 10:33:33,140
chains. Let's say for example, we wanted to deploy to Polygon


10553
10:33:33,170 --> 10:33:36,110
as well. Well, first, what are we going to need? Well, we're


10554
10:33:36,110 --> 10:33:39,590
going to need the chain ID of polygon. So a quick little


10555
10:33:39,590 --> 10:33:43,040
Google Search brings us to the polygon documentation. And we


10556
10:33:43,040 --> 10:33:48,170
see the chain ID is 137. So I'll do 137. What's a little brackets


10557
10:33:48,170 --> 10:33:54,260
here, we'll say name, polygon. Then we'll do a comma eth USD,


10558
10:33:54,800 --> 10:33:58,700
price feed. And then we'll add the price feed of eth USD on


10559
10:33:58,700 --> 10:34:04,130
polygon. So docstoc, chain link, polygon or Matic and then we'll


10560
10:34:04,130 --> 10:34:09,200
look up eth, USD. And boom, we see it right here. We've grabbed


10561
10:34:09,200 --> 10:34:12,770
this address, and we paste it in. Well, what about the


10562
10:34:12,770 --> 10:34:15,620
Hardhead? Network? We'll get to that in just a second, don't you


10563
10:34:15,620 --> 10:34:18,620
worry. And then at the bottom, we need to export this network


10564
10:34:18,620 --> 10:34:21,710
config. So our other scripts can actually work with it. So we'll


10565
10:34:21,710 --> 10:34:28,100
do module dot exports equals network config. And we're going


10566
10:34:28,100 --> 10:34:31,070
to actually export a couple of things from this file, which is


10567
10:34:31,070 --> 10:34:34,160
why we're doing it like this instead of that default way that


10568
10:34:34,160 --> 10:34:37,580
I showed you before. So back in our script, now, what can we do?


10569
10:34:37,760 --> 10:34:41,390
Well, first, we want to go ahead and import that network config.


10570
10:34:41,420 --> 10:34:47,810
So we'll say const. Network config equals require, and then


10571
10:34:47,810 --> 10:34:51,590
we'll import it, we'll go down and directory to help our


10572
10:34:51,590 --> 10:34:54,920
Hardhead config and save. And I just want to mention this one


10573
10:34:54,920 --> 10:34:57,410
more time, just so that it doesn't confuse anybody. This


10574
10:34:57,410 --> 10:35:00,710
syntax here, constant network config with the little curly


10575
10:35:00,710 --> 10:35:08,990
braces around it is the same is if I went const. Helper config


10576
10:35:10,100 --> 10:35:13,280
equals this thing, which helper config is now kind of this whole


10577
10:35:13,280 --> 10:35:21,020
file. And then const network config equals Hopper config dot


10578
10:35:21,440 --> 10:35:24,890
network config. So again, this index is just kind of an easy


10579
10:35:24,890 --> 10:35:28,610
way to extrapolate or pull out just the network config from


10580
10:35:28,610 --> 10:35:31,850
this file. So that's how that works. And that's why we export


10581
10:35:31,850 --> 10:35:35,600
it at the bottom so that we can do this, please use the GitHub


10582
10:35:35,600 --> 10:35:39,410
repository to ask questions and discussions especially about


10583
10:35:39,410 --> 10:35:41,840
some of this JavaScript stuff. Alright, great. So now that we


10584
10:35:41,840 --> 10:35:44,630
have this network configured here, we can now do this part of


10585
10:35:44,630 --> 10:35:48,950
where we say if China d z use a if chain ID is x use y. So Since


10586
10:35:48,950 --> 10:35:52,670
our helper config is nicely in this kind of dictionary, key


10587
10:35:52,670 --> 10:35:58,490
value pair style, what we can do is we can say const. eth USD.


10588
10:35:59,060 --> 10:36:08,360
Price feed address equals network config at the chain ID,


10589
10:36:08,690 --> 10:36:12,770
because if Francina D, or it'll be this object, French entity


10590
10:36:12,770 --> 10:36:21,470
polygon, it'll be this object at the eth USD price feed, we're


10591
10:36:21,470 --> 10:36:24,950
going to save this to eth USD price feed address. And now no


10592
10:36:24,950 --> 10:36:27,980
matter what chain we're on, whenever we run hard hat deploy,


10593
10:36:28,130 --> 10:36:34,550
if I run yarn, hard hat deploy dash dash network Rinkeby. This


10594
10:36:34,550 --> 10:36:37,940
chain ID is going to be four. And so it's going to use this


10595
10:36:37,940 --> 10:36:42,500
price feed address. If I do dash test network polygon, and I


10596
10:36:42,500 --> 10:36:45,560
remember to add both ring P and polygon to my networks, like


10597
10:36:45,560 --> 10:36:48,770
here, the channel is going to be 137. It's going to use this


10598
10:36:48,770 --> 10:36:52,310
price feed address. So this is awesome. This is exactly what we


10599
10:36:52,310 --> 10:36:55,340
want. But is it everything that we want? Those of you who have


10600
10:36:55,340 --> 10:36:58,040
been questioning while I have been coding and talking, you


10601
10:36:58,040 --> 10:37:00,590
might be thinking, Okay, well, you talked about this marking


10602
10:37:00,590 --> 10:37:03,500
thing. You talked about localhost and hard hat. And how


10603
10:37:03,500 --> 10:37:06,410
do we test this locally? Like this is how we go to a test net


10604
10:37:06,410 --> 10:37:09,740
and a main net. But what about a local network? And that is


10605
10:37:09,740 --> 10:37:13,370
exactly what we're going to talk about now. So we've modularized,


10606
10:37:13,370 --> 10:37:16,760
our code and parameterize our code so that we're going to use


10607
10:37:16,760 --> 10:37:20,240
the address based off of the chain that we're on. But what if


10608
10:37:20,240 --> 10:37:24,020
we use a chain that doesn't even have a price feed address on it?


10609
10:37:24,080 --> 10:37:27,470
What do we do there? This is where we actually create those


10610
10:37:27,500 --> 10:37:32,120
mock contracts. The idea of mock contracts here is if the


10611
10:37:32,120 --> 10:37:37,550
contract doesn't exist, we deploy a minimal version of it


10612
10:37:37,580 --> 10:37:42,530
for our local testing, or our local testing. And deploying


10613
10:37:42,530 --> 10:37:48,200
mocks is technically a deploy script. So what we do actually


10614
10:37:48,230 --> 10:37:51,080
is back in our deploy folder is we're going to create a new


10615
10:37:51,080 --> 10:37:58,340
file, and we're going to call it 00 Dash deploy mocks dot j s, we


10616
10:37:58,340 --> 10:38:01,670
started with 00. Because this is almost like the pre deploy


10617
10:38:01,670 --> 10:38:05,480
stuff, we only do this, sometimes we don't always deploy


10618
10:38:05,480 --> 10:38:08,750
mocks, right, we don't need to deploy mocks to Rinkeby, or


10619
10:38:08,750 --> 10:38:11,810
polygon or or Aetherium main net, because those already have


10620
10:38:11,810 --> 10:38:15,200
these price feeds, we're actually going to deploy our own


10621
10:38:15,350 --> 10:38:19,700
mock price feed contracts. And in our deploy Funmi script,


10622
10:38:19,730 --> 10:38:23,780
we're going to use our own contracts, instead of already


10623
10:38:23,780 --> 10:38:26,990
established contracts. If we're on a network that doesn't have


10624
10:38:27,020 --> 10:38:30,770
any price, few contracts, like hard hat or locos, for example.


10625
10:38:30,860 --> 10:38:34,160
So let's write our deploy mock script. So the setup of this is


10626
10:38:34,160 --> 10:38:37,430
going to look nearly identical to our deploy Funmi. And again,


10627
10:38:37,430 --> 10:38:41,270
if you want to set it up like this, you absolutely can. But


10628
10:38:41,270 --> 10:38:43,880
I'm actually just going to copy this, this part, paste it in


10629
10:38:43,880 --> 10:38:46,820
here, because that initial part is going to be exactly the same.


10630
10:38:47,000 --> 10:38:49,340
Oh, and over here, I just realized that we're calling this


10631
10:38:49,340 --> 10:38:52,160
network thing without being defined, JavaScript will kind of


10632
10:38:52,160 --> 10:38:54,770
be smart enough to know where this network thing is coming


10633
10:38:54,770 --> 10:38:57,860
from. But it can be a little bit confusing. So it's better to be


10634
10:38:57,860 --> 10:39:03,740
really explicit, and say, const. Network equals require hard hat,


10635
10:39:03,980 --> 10:39:07,130
this network thing is coming from hard hat. And we're going


10636
10:39:07,130 --> 10:39:10,370
to grab this line. And we're also going to use this at the


10637
10:39:10,370 --> 10:39:13,460
top of our script here. And then our top section is going to look


10638
10:39:13,490 --> 10:39:16,160
exactly the same as well, we're going to grab these three lines,


10639
10:39:16,250 --> 10:39:19,490
and paste them in deploy deployer chain ID, boom, it's


10640
10:39:19,490 --> 10:39:21,530
all going to be the same here, because we're setting up to


10641
10:39:21,530 --> 10:39:25,100
deploy some stuff. Now we want to deploy a new contract. But if


10642
10:39:25,100 --> 10:39:28,460
we look at our contracts folder, this is all we have right now.


10643
10:39:28,580 --> 10:39:32,450
So we're going to need to add this mock this fake contract to


10644
10:39:32,450 --> 10:39:35,330
our contracts folder. Now what we can do is in our contracts


10645
10:39:35,330 --> 10:39:38,810
folder, we want to separate this file from the rest of our file


10646
10:39:38,810 --> 10:39:41,900
so that we know okay, this isn't part of our project, but it is


10647
10:39:41,900 --> 10:39:44,990
part of our testing. So we're going to right click Create New


10648
10:39:44,990 --> 10:39:49,160
Folder. And we can either call it mocks, or test I like to call


10649
10:39:49,160 --> 10:39:52,220
mine test. And inside of this folder, we can go ahead and


10650
10:39:52,220 --> 10:39:54,890
right click create a new file, I'm going to create a new file


10651
10:39:54,920 --> 10:40:01,940
and call it mock, v3 aggregate tore that soul. And this is


10652
10:40:01,940 --> 10:40:05,360
where we're going to define our mock price feed aggregator


10653
10:40:05,390 --> 10:40:09,650
ourselves. So how can we create our own fake price feed


10654
10:40:09,650 --> 10:40:12,620
contract, so we can test everything locally? Well, one


10655
10:40:12,620 --> 10:40:16,010
thing we could do is we go to the chain link GitHub repo, and


10656
10:40:16,010 --> 10:40:18,470
go through the contracts and find one of these price feed


10657
10:40:18,470 --> 10:40:22,640
addresses, source eight, or maybe we'll go back to source


10658
10:40:22,640 --> 10:40:24,500
we'll maybe we'll check in V six.


10659
10:40:26,360 --> 10:40:29,510
Looks like we could find some stuff and look around and we


10660
10:40:29,510 --> 10:40:32,690
probably copy paste all this code, but it really seems like


10661
10:40:32,690 --> 10:40:35,060
kind of a huge pain in the butt to have to copy all this code.


10662
10:40:35,210 --> 10:40:38,210
Now we absolutely could we copy paste the code in here, but


10663
10:40:38,210 --> 10:40:40,460
we're gonna do something a little bit more clever. So the


10664
10:40:40,460 --> 10:40:44,750
chainlink repo actually comes with some mocks. If we go to


10665
10:40:44,750 --> 10:40:52,040
contracts, SRC V 0.6 tests They actually have a mock v3


10666
10:40:52,040 --> 10:40:56,210
aggregator dot soul in here that we can use as our mock. So we


10667
10:40:56,210 --> 10:40:59,690
can copy paste everything, but we'd have to revamp a little bit


10668
10:40:59,690 --> 10:41:03,080
of it because it's doing some dot dot stuff. It's talking to


10669
10:41:03,080 --> 10:41:06,530
other contracts that are locally in this file structure that are


10670
10:41:06,530 --> 10:41:10,010
not going to be in our file structure. So instead though,


10671
10:41:10,040 --> 10:41:13,340
what we can do is we can use this node modules package to our


10672
10:41:13,340 --> 10:41:19,130
advantage, we can just say pragma, solidity, carrot zero,


10673
10:41:19,670 --> 10:41:22,610
point 6.0, we'll use the same version that that package is


10674
10:41:22,610 --> 10:41:28,130
doing. And then just do import at a chain link slash contracts


10675
10:41:28,160 --> 10:41:35,840
slash SRC slash v 0.6. Slash tests slash mock, B, three egg,


10676
10:41:35,840 --> 10:41:40,340
Reg, gay tore that soul. And then we'll add, and then of


10677
10:41:40,340 --> 10:41:46,040
course, we'll add spdx, license identifier, MIT. And boom, this


10678
10:41:46,040 --> 10:41:50,930
is actually all we need. If we just import the code like this,


10679
10:41:50,960 --> 10:41:54,830
remember, this is exactly the same as copy pasting this


10680
10:41:54,830 --> 10:41:59,000
contract into our project, of course, with this path resolve


10681
10:41:59,000 --> 10:42:03,140
to where it actually is in our node modules. Now, actually, I


10682
10:42:03,140 --> 10:42:07,910
can run yarn hardhat compile, and it will also compile this


10683
10:42:07,910 --> 10:42:12,350
contract. Except for of course, we have an issue, hey, compiler


10684
10:42:12,350 --> 10:42:15,530
versions don't match. Right? What's What's up with that now,


10685
10:42:15,560 --> 10:42:18,020
you're going to get into situations where you will be


10686
10:42:18,020 --> 10:42:20,780
working with contracts that are not the same version of solidity


10687
10:42:20,780 --> 10:42:23,840
as you why well because contracts keep being deployed


10688
10:42:23,870 --> 10:42:26,660
all the time. And there are a ton of contracts that are in


10689
10:42:26,660 --> 10:42:32,540
version 0.4, solidity, 0.5 0.678, and probably 910, or


10690
10:42:32,540 --> 10:42:35,180
15 billion, or however many solidity versions will come to


10691
10:42:35,180 --> 10:42:38,930
be. So in our config, in our hard hat dot config, when you


10692
10:42:38,930 --> 10:42:41,870
scroll to the bottom, we can scroll to where we're defining


10693
10:42:41,900 --> 10:42:45,500
our solidity version. And we can actually add multiple solidity


10694
10:42:45,500 --> 10:42:49,520
versions, so that our compiler can compile multiple versions of


10695
10:42:49,520 --> 10:42:54,110
solidity. To do that, we'll say, so Lyd, did T. And we'll turn it


10696
10:42:54,110 --> 10:42:57,890
into an object here, we'll make sure to put this comma here. And


10697
10:42:57,890 --> 10:43:01,850
inside our solidity object, we'll put compilers and we'll


10698
10:43:01,850 --> 10:43:05,840
have a list of compilers. Our first one we'll say is version,


10699
10:43:06,260 --> 10:43:09,770
zero, point 8.8. And we'll say our second one is going to be


10700
10:43:09,770 --> 10:43:15,080
version 0.6, point six, and then we'll go ahead and save that.


10701
10:43:15,680 --> 10:43:17,900
And it looks like mine wanted to format it like this, which is


10702
10:43:17,900 --> 10:43:21,830
fine. Now, we can go ahead, rerun, yarn, Hardhead, compile,


10703
10:43:22,430 --> 10:43:26,360
and boom, compiled five solidity files successfully. This means


10704
10:43:26,360 --> 10:43:29,840
that our Mark V aggregator should also have been compiled.


10705
10:43:29,900 --> 10:43:34,340
And if we look in artifacts, at chain link, do indeed see this


10706
10:43:34,340 --> 10:43:38,870
at chain link slash contract slash SRC bid, and a v 0.6. In


10707
10:43:38,870 --> 10:43:41,570
tests, we see this mock aggregator dot soul, which has


10708
10:43:41,570 --> 10:43:45,620
been compiled. Awesome. So now that we have our mock contract


10709
10:43:45,650 --> 10:43:50,180
compiled, we now have a contract that we can use to deploy a fake


10710
10:43:50,180 --> 10:43:53,660
price feed to a blockchain. So how do we actually do this?


10711
10:43:53,780 --> 10:43:56,690
Well, it's going to be the exact same way that we deployed the


10712
10:43:56,690 --> 10:43:59,420
Funmi contract. But we're going to add a little if statement in


10713
10:43:59,420 --> 10:44:04,400
here, we don't want to deploy this mock contract to a test net


10714
10:44:04,400 --> 10:44:08,390
or a network that actually has a price feed on it, we could just


10715
10:44:08,390 --> 10:44:13,220
do something like if chain ID does not equal, you know, some


10716
10:44:13,220 --> 10:44:17,270
chain ID, then deploy marks, right. And then this is kind of


10717
10:44:17,270 --> 10:44:19,640
pseudocode. Obviously, this code won't actually work. But


10718
10:44:19,640 --> 10:44:22,910
instead, what I like is I actually like to specify which


10719
10:44:22,910 --> 10:44:25,550
chains are going to be my development chains, which chains


10720
10:44:25,550 --> 10:44:29,600
are going to be the one that I can deploy these mocks to, in my


10721
10:44:29,600 --> 10:44:32,960
helper, hard hat config, I'll define these chains. So I'll say


10722
10:44:32,960 --> 10:44:38,630
const, development chains, equals, and then I'll just say


10723
10:44:38,630 --> 10:44:45,980
hard hat, and local host. I'll export these. And back in my


10724
10:44:45,980 --> 10:44:51,350
deploy mocks, I'll import these with const. Development chains


10725
10:44:51,380 --> 10:44:58,040
equals require dot dot slash helper Hardhead config. And now


10726
10:44:58,160 --> 10:45:06,170
I'll say if development chains dot includes chain ID. This


10727
10:45:06,170 --> 10:45:10,040
includes keyword basically is a function that checks to see if


10728
10:45:10,190 --> 10:45:13,430
some variable is inside an array, then we're gonna go ahead


10729
10:45:13,430 --> 10:45:17,030
and deploy Max, and which is what we want to do. So we'll do


10730
10:45:17,090 --> 10:45:19,760
log, which we're getting from deployments, which is basically


10731
10:45:19,760 --> 10:45:24,980
console dot log. And we'll say local network detected,


10732
10:45:25,640 --> 10:45:27,620
deploying mocks.


10733
10:45:28,970 --> 10:45:34,940
And we'll do a weight ploy, and we'll deploy our new mock v3


10734
10:45:34,940 --> 10:45:40,130
aggregator mock v3 aggregator will do a comma. There a little


10735
10:45:40,130 --> 10:45:43,430
colons here. If we want to get really specific, we can say


10736
10:45:43,430 --> 10:45:47,630
contract v3 aggregator which we're kind of already saying


10737
10:45:47,660 --> 10:45:51,680
we'll say from deployer We'll say logging is going to be true.


10738
10:45:53,030 --> 10:45:56,390
And then we need to pass some arguments, we need to pass the


10739
10:45:56,390 --> 10:46:00,080
constructor parameters for the mock v3 aggregator, which are


10740
10:46:00,170 --> 10:46:04,310
what? Well, let's go to docs chain to link to find out. Or


10741
10:46:04,340 --> 10:46:09,800
you can also just go to Node modules chainlink, SRC V 06,


10742
10:46:10,010 --> 10:46:13,790
tests, and then all the way down to mock V three, aggregated out.


10743
10:46:13,790 --> 10:46:17,270
So where you could also find the constructor in here, whatever


10744
10:46:17,270 --> 10:46:19,640
one you like better, sometimes I find it easier just to read


10745
10:46:19,640 --> 10:46:24,680
GitHub Ctrl plus F or Command plus F for constructor. We see


10746
10:46:25,160 --> 10:46:29,570
it takes a decimals and an initial answer. And if we read


10747
10:46:29,570 --> 10:46:33,050
through the code, we'll learn that the decimals object is


10748
10:46:33,050 --> 10:46:36,380
going to be equivalent to the decimals parameter is going to


10749
10:46:36,380 --> 10:46:40,700
be equivalent to this decimals function and the initial answer.


10750
10:46:40,970 --> 10:46:43,190
And the initial answer is basically just going to be what


10751
10:46:43,190 --> 10:46:45,680
is the price feed starting at, we actually get to pick the


10752
10:46:45,680 --> 10:46:48,710
price of the price feed, which works out really well, because


10753
10:46:48,710 --> 10:46:51,170
that works out great for testing. I usually like to


10754
10:46:51,170 --> 10:46:53,780
define the decimals and the initial answers somewhere


10755
10:46:53,780 --> 10:46:57,050
outside of this function so that I can access it later. One good


10756
10:46:57,050 --> 10:47:00,410
place you can add it is once again in our helper Hardhead


10757
10:47:00,410 --> 10:47:06,740
config.js. So I might do const decimals equals eight. And then


10758
10:47:06,740 --> 10:47:15,740
const initial answer. Answer equals, and we'll do 2000. So


10759
10:47:15,770 --> 10:47:20,930
since we have a decimals, we'll do 2000 And then 123456788


10760
10:47:20,930 --> 10:47:24,650
decimal places, and then we'll export these as well. Export


10761
10:47:24,650 --> 10:47:28,760
decimals, and export initial answer. We could of course, just


10762
10:47:28,760 --> 10:47:32,480
do you know, const decimals equals eight at the top and then


10763
10:47:32,480 --> 10:47:35,540
initial answer and then use them down here. But I like to do it


10764
10:47:35,540 --> 10:47:38,660
like that. So Conce. So now we have to import them in here.


10765
10:47:39,260 --> 10:47:43,640
const development chains. It's also grabbed decimals. It's also


10766
10:47:43,640 --> 10:47:47,120
grabbed initial answer, we'll save it. We'll take a look back


10767
10:47:47,120 --> 10:47:49,550
at the constructor looks like it's decimals first, initial


10768
10:47:49,550 --> 10:47:52,820
answers second. So in our arguments, we'll do decimals


10769
10:47:52,820 --> 10:47:57,440
first, initial answers second, and tada. And then we will be


10770
10:47:57,440 --> 10:48:01,940
all done that we'll do a quick log box deployed. And then I


10771
10:48:01,940 --> 10:48:05,450
also like to do kind of like a big line at the end of all of my


10772
10:48:05,450 --> 10:48:08,030
deploy scripts just to be like, hey, that's the end of this


10773
10:48:08,030 --> 10:48:11,180
deploy script. Anything else after this is going to be a


10774
10:48:11,180 --> 10:48:14,390
different deploy script. All right, great. Now our deployed


10775
10:48:14,390 --> 10:48:17,600
mocks script is actually done. But our deploy Funmi script


10776
10:48:17,840 --> 10:48:21,770
isn't quite done. Is there a way that we could run only our


10777
10:48:21,770 --> 10:48:25,190
deploy mock script? Well, yes, there is. Great, thanks for


10778
10:48:25,190 --> 10:48:27,890
asking. What we can do at the bottom of our deploy mock script


10779
10:48:27,920 --> 10:48:35,000
is we can add a module that exports dot tags, equals, and


10780
10:48:35,000 --> 10:48:40,430
we'll say all and marks. Now what we can do is if we run


10781
10:48:40,430 --> 10:48:45,770
yarn, hard hat deploy, we can add this flag dash dash tags.


10782
10:48:46,190 --> 10:48:50,540
And it will only run the deploy scripts that have a special tag.


10783
10:48:50,930 --> 10:48:55,310
So we'll run our mocks tag, which means it'll only run our


10784
10:48:55,310 --> 10:48:59,840
deploy mock script. And, and oops, actually, in our helper


10785
10:48:59,840 --> 10:49:03,440
config development chains is actually hard hat and localhost.


10786
10:49:03,440 --> 10:49:06,860
And I said, we're going to try to do with the chain ID, sorry,


10787
10:49:06,890 --> 10:49:09,380
we're going to do this, we're gonna do development chains dot


10788
10:49:09,380 --> 10:49:11,990
includes network dot name.


10789
10:49:15,350 --> 10:49:19,880
Because our helper config is using names and not chain IDs,


10790
10:49:19,910 --> 10:49:23,030
so if development chains that includes that network the names,


10791
10:49:23,060 --> 10:49:25,670
then we're gonna go ahead and deploy the mocks. So let's go


10792
10:49:25,670 --> 10:49:28,730
ahead and run this yarn here and hit Deploy dash dash tags,


10793
10:49:28,730 --> 10:49:32,990
mocks. And perfect we do indeed see our mocks getting deployed


10794
10:49:32,990 --> 10:49:36,620
here. This log true means that it's going to spit out stuff


10795
10:49:36,620 --> 10:49:39,560
like this. It'll say contract, it's deploying, it'll say the


10796
10:49:39,560 --> 10:49:42,830
transaction it's doing and it'll say where it was deployed with


10797
10:49:42,830 --> 10:49:47,000
how much gas and awesome This means our deployed Mach script


10798
10:49:47,000 --> 10:49:50,570
is working perfectly. So now we have our deploy mocks script


10799
10:49:50,600 --> 10:49:54,170
working perfectly. So how do we apply that back to our deploy


10800
10:49:54,200 --> 10:49:57,440
Funmi script? Well, we're gonna do the exact same thing here.


10801
10:49:57,980 --> 10:50:01,070
Instead of making eth USD price feed address constant variable,


10802
10:50:01,100 --> 10:50:04,700
we're gonna say let at USD price you'd variable so that we can


10803
10:50:04,700 --> 10:50:09,800
actually update it. And we'll say, if development chains dot


10804
10:50:09,800 --> 10:50:15,650
includes network dot name, what we can do with hard hat deploy


10805
10:50:15,680 --> 10:50:19,010
is we can just get the most recent deployment using a


10806
10:50:19,010 --> 10:50:23,840
command called literally get. So we'll say const. eth USD


10807
10:50:23,840 --> 10:50:30,200
aggregator equals await deployments dot get. And then


10808
10:50:30,200 --> 10:50:34,280
the name of the contract that we deployed Mach v3 aggregator, and


10809
10:50:34,280 --> 10:50:37,040
if you wanted to just do get instead of deployments dot get,


10810
10:50:37,220 --> 10:50:42,020
we absolutely could, just by doing it like this. Those are


10811
10:50:42,020 --> 10:50:45,080
exactly the same. So we'll get the address like this and then


10812
10:50:45,080 --> 10:50:52,400
we'll say eth USD price feed address equals that eth USD


10813
10:50:52,400 --> 10:50:56,900
aggregator contract dot address. And then if we're not on a


10814
10:50:56,900 --> 10:51:00,380
development chain, if we didn't deploy a mock, we're just going


10815
10:51:00,380 --> 10:51:04,160
to do exactly what we did before. With using the network


10816
10:51:04,160 --> 10:51:09,740
config. Oh, my goodness. Now, now that we've done all of these


10817
10:51:09,740 --> 10:51:13,070
steps, let's add a little log thing at the bottom here with


10818
10:51:13,070 --> 10:51:18,260
just a bunch of hyphens. Now, we should have a very robust script


10819
10:51:18,440 --> 10:51:22,340
to flip between a local development chain, a test net


10820
10:51:22,340 --> 10:51:25,820
chain, a main net chain, and allow us to deploy literally


10821
10:51:25,820 --> 10:51:29,330
everywhere without changing any of our solidity. And then we


10822
10:51:29,330 --> 10:51:33,770
just take this, this eth USD price feed address and stick it


10823
10:51:34,460 --> 10:51:38,450
into logs here. And then at the bottom, we can do module dot


10824
10:51:38,450 --> 10:51:43,490
exports, dot tags equals and then we'll just do all and then


10825
10:51:43,490 --> 10:51:48,650
we'll call this one Funmi. Oh, now moment of truth. If we did


10826
10:51:48,650 --> 10:51:52,430
all this, right, we should just be able to run yarn, hard hat


10827
10:51:52,430 --> 10:51:57,110
deploy. And it should work on our local chain, our hard hat


10828
10:51:57,110 --> 10:52:00,500
chain. And then it should also work on any test net that we


10829
10:52:00,500 --> 10:52:03,950
give it. So let's give this a try. Yarn, Hardhead deploy.


10830
10:52:04,340 --> 10:52:07,460
Let's see if this works. Awesome. And we got this all to


10831
10:52:07,460 --> 10:52:11,780
deploy locally to our Hard Hat Network, we can see that we went


10832
10:52:11,780 --> 10:52:14,780
ahead and we deployed mocks, we did our little underline here.


10833
10:52:15,170 --> 10:52:18,020
And then we deployed Funmi deployed at this address with


10834
10:52:18,050 --> 10:52:21,560
this much gas. Now, what are the other awesome things about hard


10835
10:52:21,560 --> 10:52:24,680
hat deploy? When we run our local blockchain, our own


10836
10:52:24,680 --> 10:52:28,880
blockchain node, hard hat deploy will automatically run through


10837
10:52:29,060 --> 10:52:33,290
all of our deploy scripts and add them to our node. So now if


10838
10:52:33,290 --> 10:52:38,420
I run yarn, hard hat node, we're going to spin up a new


10839
10:52:38,420 --> 10:52:41,690
blockchain node, but it's already going to have all of our


10840
10:52:41,690 --> 10:52:45,140
deployed contracts on it. So every time we spin up a local


10841
10:52:45,140 --> 10:52:48,530
node, now it's going to come automatically packed with the


10842
10:52:48,530 --> 10:52:54,500
contracts that we want on it. 